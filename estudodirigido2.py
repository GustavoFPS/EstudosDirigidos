# -*- coding: utf-8 -*-
"""EstudoDirigido2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_AU3OUokjS9pugzi9geqph5KSlbvKVjb
"""

# -*- coding: utf-8 -*-
"""
Created on Mon Oct 16 11:04:58 2023

@author: talgu
"""
import numpy as np
import matplotlib.pyplot as plt
import random
import time
import cProfile
import sys


def H_WF(J1, J2, p1, p2, a, b):
    '''
    Calcula a hamiltoniana de Walker-Ford a partir das variáveis de ângulo e
    ação

    Parameters
    ----------
    J1 : float
        Ação
    J2 : float
        Ação
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    a : float
        Parâmetro
    b : float
        Parâmetro

    Returns
    -------
    H : float
        Hamiltoniana de Walker-Ford
    H_0 : float
        Hamiltoniana não perturbada
    H_1 : float
        Perturbação

    '''

    H_0 = J1 + J2 - J1**2 - 3*J1*J2 + J2**2
    H_1 = a* J1 *J2 * np.cos(2*p1 - 2*p2) + b* J1 * (J2**(3/2))*np.cos(2*p1 - 3*p2)
    H = H_0 + H_1

    return H, H_0, H_1

def dH(p1, J1, p2, J2, a, b, dt):
    '''
    Função que calcula a derivada parcial da hamiltoniana

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    dt : float
        Passo temporal

    Returns : dp1/dt, dp2/dt, dJ1/dt, dJ2/dt
    -------
    '''

    #funções trigonométricas
    cos22 = np.cos(2*p1 - 2*p2)
    cos23 = np.cos(2*p1 -3*p2)
    sin22 = np.sin(2*p1 - 2*p2)
    sin23 = np.sin(2*p1 -3*p2)

    #derivadas temporais
    dp1_dt = 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23
    dp2_dt = 1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23

    dJ1_dt = +2*a*J1*J2*sin22 + 2*b*J1*(J2**(3/2))*sin23
    dJ2_dt = -2*a*J1*J2*sin22 - 3*b*J1*(J2**(3/2))*sin23

    return  dp1_dt, dp2_dt, dJ1_dt, dJ2_dt


def euler(x_n, y_n, dHx, dHy, delta_t):
    '''
    Calcula o método de euler para as variáveis phi e J usando a derivada
    parcial correspondente

    Parameters
    ----------
    x_n : float
        variável integrada
    y_n : float
        variável não integrada
    dHx : float
        derivada parcial da hamiltoniana em função da variável integrada
    dHy : float
        derivada parcial da hamiltoniana em função da variável integrada
    delta_t : float
        passo de tempo para integração

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    y_(n+1) = y_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    -------
    '''
    return x_n + delta_t*dHx, y_n + delta_t*dHy

def newton(p1_n1, p1_ne, p2_n1, p2_ne, dt, J1, J2, a, b, e):
    '''
    Calcula o método de Newton para determinar phi^{n+1}

    Parameters
    ----------
    p1_n1 : float
        Chute para o método de newton.
    p1_ne : float
        Resultado interior da integração numérica.
    p2_n1 : float
        Chute para o método de newton.
    p2_ne : float
        Resultado interior da integração numérica.
    dt : float
        Passo temporal.
    J1 : float
        Variável de ação da integração numérica.
    J2 : float
        Variável de ação da integração numérica.
    a : float
        Parâmetro
    b : float
        Parâmetro
    e : float
        Erro requirido.

    Returns ph1^{n+1}, phi2^{n+2}
    -------
    '''

    while True: #intera indefinidamente

        p1_n = p1_n1
        p2_n = p2_n1

        #funções trignométricas
        cos22 = np.cos(2*p1_n - 2*p2_n)
        cos23 = np.cos(2*p1_n -3*p2_n)
        sin22 = np.sin(2*p1_n - 2*p2_n)
        sin23 = np.sin(2*p1_n -3*p2_n)

        #g1 e g2
        g1 = p1_n - p1_ne - dt * ( 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23)
        g2 = p2_n - p2_ne - dt * (1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23)

        if np.abs(g1) < e or np.abs(g2) < e: #verifica se está menor que o erro aceitável
            break

        B = [-g1, -g2] #matriz B

        #elementos da matriz A
        dg1_dp1 = 1 -dt * (-2  * a*J2*sin22 - 2 * b*(J2**(3/2))*sin23)
        dg1_dp2 =  -dt * (2 * a*J2*sin22 + 3 * b*(J2**(3/2))*sin23)
        dg2_dp1 = -dt * (-2 * a*J1*sin22 - 3 *b*J1*(J2**(1/2))*sin23)
        dg2_dp2 = 1 -dt * (+2 * a*J1*sin22 + (9/2) *b*J1*(J2**(1/2))*sin23)

        #matriz A
        A = [[dg1_dp1, dg1_dp2],[dg2_dp1, dg2_dp2]]

        #decomposição LU
        u11 = A[0][0]
        l21 = (A[1][0])/u11
        u12 = A[0][1]
        u22 = A[1][1] - l21*u12

        #L = [[1, 0], [l21, 1]] #matriz L

        #U = [[u11, u12], [0, u22]] #matriz U

        #solução do método de newton pelo método LU
        x1 = B[0]

        x2 = B[1] - l21*x1

        q2 = x2/u22

        q1 = (x1 - u12*q2)/u11

        #atualiza as variáveis
        p1_n1 = q1 + p1_n

        p2_n1 = q2 + p2_n

    return p1_n1, p2_n1

def con_iniciais(p1, p2, J2, a, b, E = 0.08333):
    '''
    Calcula J1 por bhaskara a partir da fixação das outras variáveis da hamiloniana
    Parameters
    ----------
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    E : float, opcional
        Energia. O padrão é 0.08333.

    Returns p1, p2, J1, J2
    -------
    '''
    #J**2 - J1*(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2)) + E - J2**2

    #bhaskara
    a_bk = 1
    b_bk = -1* float(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2))
    c_bk = E - J2**2 - J2

    J1 = (-b_bk + ((b_bk*b_bk - 4*a_bk*c_bk)**(1/2)))/(2*a_bk)

    return p1, p2, J1, J2

def henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, u):
    '''
    Calcula o método de Henon para determinar a seção de Poicaré em termos das
    coordenadas de posição e momento

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    dp1 : float
        Derivada temporal de phi1
    dp2 : float
        Derivada temporal de phi2
    dJ1 : float
        Derivada temporal de J1
    dJ2 : float
        Derivada temporal de J2
    a : float
        Parâmetro
    b : float
        Parâmetro
    u : float
        Distância entre o ponto fixado e a seção de poicaré

    Returns q1, q2, m1, m2
    -------
    '''
    #método de henon
    p1 = p1
    p2 += u * (dp2/dp1)
    J1 += u * (dJ1/dp1)
    J2 += u * (dJ2/dp1)

    #cálculo da posição e momento
    q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)
    q2, m2 = ((2*J2)**(1/2))*np.cos(p2), -((2*J2)**(1/2))*np.sin(p2)
    return q1, q2, m1, m2

#parâmetros do EP
a = 0.02
b = 0.02
E = 0.0561

#configuração da interação
dt = 0.05
t_max = 1*10**4

#cores dos gráficos
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

#chutes iniciais para J2
iniciaisJ = [2*0.115, 0.115]#, 0.115, 0.0200, 0.07, 0.0200, 0.005, 0.0025]#
#controle do tempo de execução
start_time_ini = time.time()

#grandezas analisadas no EP
F2 = []
F1 = []
tempo = []
En =[]

#para cada chute inicial
for i in range(0, len(iniciaisJ), 1):
    #cria as listas para armazenar as variáveis de
    En.append([])
    t_henon = []
    lista_henon = []
    q2_henon = []
    m2_henon = []
    q1_list = []

    #checa se J1 é real ou não
    checa = False
    while checa == False:
        p1_n, p2_n, J1_n, J2_n = con_iniciais(3*np.pi/2, random.uniform(0, 2*np.pi), iniciaisJ[i], a, b, E)
        if type(J1_n) is not complex and J1_n > 0:
            checa = True

    #mostra quantos porcento foi execultado para cada chute inicial
    ax = None
    for t in np.arange(0, t_max, dt):
        porcent = str(100* t//t_max)

        if porcent != ax:
            print('% = ', 100* t//t_max, '%')
            ax = str(100* t//t_max)

    #uso um try para evitar erros
        try:

          p1, p2 = newton(0, p1_n, 0, p2_n, dt, J1_n, J2_n, a, b, 10**(-13))

          dp1, dp2, dJ1, dJ2 = dH(p1, J1_n, p2, J2_n, a, b, dt)
          J1 = euler(p1_n, J1_n, dp1, dJ1, dt)[1]
          J2 = euler(p2_n, J2_n, dp2, dJ2, dt)[1]
          En[i].append(H_WF(J1, J2, p1, p2, a, b)[0])

          #apenas para a primeira trajetória e para tempo menor que 100, gera os dados para F1 e F2
          if i == 0 and t < 100:
              tempo.append(t)
              F1.append(J1 + J2)
              F2.append(3*J1 + 2*J2)

          #converte os pontos para momento e posição
          q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)

          #se é a primeira interação eu calculo a posição anterior explicitamente
          if t == 0:
              q1_n =  ((2*J1_n)**(1/2))*np.cos(p1_n)

          #atualizado as variáveis para próxima interação
          p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #para checar se está calculando corretamente
          q1_list.append(q1)

          #ALCIDES, ISSO AQUI É O MÉTODO QUE TEM QUE USAR, O DE BAIXO FOI EU METENDO O LOUCO PARA INTERAR MAIS VEZES
          '''if q1*q1_n < 0 and m1 >= 0:  #Seção de Poincaré no plano p2 x q2
            tg = np.arctan2(m1, q1)
            if tg < 0:
                tg += 2*np.pi
            lista_henon.append(list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/(m1**2 + q1**2))*q1)))
            t_henon.append(t)'''

          #atualizo q1
          q1_n = q1

          #método aconchabrado
          if np.abs(q1) < 10**(-2) and m1 >= 0:
              lista_henon.append(list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/(m1**2 + q1**2))*q1)))
              t_henon.append(t)

        except:
            continue

    print('saiu') #sinaliza que deu tudo certo

    #armazena o momento e posição para gerar a seção de poicaré
    for element in lista_henon:
      q2_henon.append(element[1])
      m2_henon.append(element[3])

    #plota a seção de poicaré
    plt.figure(1, figsize=(8, 6))
    plt.scatter(q2_henon, m2_henon, color=colors[i], s = 0.2)

    #abaixo é para gerar gráficos da energia e verificar se está sendo uma constante de movimento
    '''plt.scatter(tempo, En[i], color=colors[i], s = 0.2)
    plt.ylim(0.16, 0.19)'''

#tempo de execução
end_time_ini = time.time()
timefinal = str((end_time_ini - start_time_ini)//60) + ' minutos e ' + str(round((end_time_ini - start_time_ini)%60,2)) + ' segundos'
print("Essa operação levou {}".format(timefinal))

#parâmetros dos gráficos
plt.title('Seção de Poincaré para E = {0}'.format(E))
plt.xlabel('$q_2$')
plt.ylabel('$p_2$')
plt.grid()
plt.show()

#abaixo cria os gráficos de F1 e F2
#MAS ALGO ESTÁ ERRADO, QUANDO VC USA max(F1) e min(F1) DA PRA VER QUE É UMA CONSTANTE
#DE MOVIMENTO, MAS NO GRÁFICO PARECE QUE NÃO, NÃO ENTENDI O QUE ACONTECEU E NÃO TIVE TEMPO '''acho que agora foi'''
#DE VERIFICAR PARA ARRUMAR
'''
plt.figure(2, figsize=(8, 6))
plt.scatter(tempo, F1, color=colors[i], s = 0.2)
plt.ylim(min(F1)+ 10**(-6), max(F1)- 10**(-6))
plt.xlabel('$t$')
plt.ylabel('$F1$')


plt.figure(3, figsize=(8, 6))
plt.scatter(tempo, F2, color=colors[i], s = 0.2)
plt.ylim( min(F2), max(F2))
plt.xlabel('$t$')
plt.ylabel('$F2$')
plt.show()'''
'''
for j, element in enumerate(En):
    plt.figure(j + 2, figsize=(8, 6))
    plt.scatter(tempo, element, color=colors[j], s = 0.2)
    plt.xlabel('$t$')
    plt.ylabel('$E$')
    plt.grid()
    plt.show()'''

# -*- coding: utf-8 -*-
"""
Created on Mon Oct 16 11:04:58 2023

@author: talgu
"""
import numpy as np
import matplotlib.pyplot as plt
import random
import time
import cProfile
import sys


def H_WF(J1, J2, p1, p2, a, b):
    '''
    Calcula a hamiltoniana de Walker-Ford a partir das variáveis de ângulo e
    ação

    Parameters
    ----------
    J1 : float
        Ação
    J2 : float
        Ação
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    a : float
        Parâmetro
    b : float
        Parâmetro

    Returns
    -------
    H : float
        Hamiltoniana de Walker-Ford
    H_0 : float
        Hamiltoniana não perturbada
    H_1 : float
        Perturbação

    '''

    H_0 = J1 + J2 - J1**2 - 3*J1*J2 + J2**2
    H_1 = a* J1 *J2 * np.cos(2*p1 - 2*p2) + b* J1 * (J2**(3/2))*np.cos(2*p1 - 3*p2)
    H = H_0 + H_1

    return H, H_0, H_1

def dH(p1, J1, p2, J2, a, b, dt):
    '''
    Função que calcula a derivada parcial da hamiltoniana

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    dt : float
        Passo temporal

    Returns : dp1/dt, dp2/dt, dJ1/dt, dJ2/dt
    -------
    '''

    #funções trigonométricas
    cos22 = np.cos(2*p1 - 2*p2)
    cos23 = np.cos(2*p1 -3*p2)
    sin22 = np.sin(2*p1 - 2*p2)
    sin23 = np.sin(2*p1 -3*p2)

    #derivadas temporais
    dp1_dt = 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23
    dp2_dt = 1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23

    dJ1_dt = +2*a*J1*J2*sin22 + 2*b*J1*(J2**(3/2))*sin23
    dJ2_dt = -2*a*J1*J2*sin22 - 3*b*J1*(J2**(3/2))*sin23

    return  dp1_dt, dp2_dt, dJ1_dt, dJ2_dt


def euler(x_n, y_n, dHx, dHy, delta_t):
    '''
    Calcula o método de euler para as variáveis phi e J usando a derivada
    parcial correspondente

    Parameters
    ----------
    x_n : float
        variável integrada
    y_n : float
        variável não integrada
    dHx : float
        derivada parcial da hamiltoniana em função da variável integrada
    dHy : float
        derivada parcial da hamiltoniana em função da variável integrada
    delta_t : float
        passo de tempo para integração

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    y_(n+1) = y_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    -------
    '''
    return x_n + delta_t*dHx, y_n + delta_t*dHy

def newton(p1_n1, p1_ne, p2_n1, p2_ne, dt, J1, J2, a, b, e):
    '''
    Calcula o método de Newton para determinar phi^{n+1}

    Parameters
    ----------
    p1_n1 : float
        Chute para o método de newton.
    p1_ne : float
        Resultado interior da integração numérica.
    p2_n1 : float
        Chute para o método de newton.
    p2_ne : float
        Resultado interior da integração numérica.
    dt : float
        Passo temporal.
    J1 : float
        Variável de ação da integração numérica.
    J2 : float
        Variável de ação da integração numérica.
    a : float
        Parâmetro
    b : float
        Parâmetro
    e : float
        Erro requirido.

    Returns ph1^{n+1}, phi2^{n+2}
    -------
    '''

    while True: #intera indefinidamente

        p1_n = p1_n1
        p2_n = p2_n1

        #funções trignométricas
        cos22 = np.cos(2*p1_n - 2*p2_n)
        cos23 = np.cos(2*p1_n -3*p2_n)
        sin22 = np.sin(2*p1_n - 2*p2_n)
        sin23 = np.sin(2*p1_n -3*p2_n)

        #g1 e g2
        g1 = p1_n - p1_ne - dt * ( 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23)
        g2 = p2_n - p2_ne - dt * (1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23)

        if np.abs(g1) < e or np.abs(g2) < e: #verifica se está menor que o erro aceitável
            break

        B = [-g1, -g2] #matriz B

        #elementos da matriz A
        dg1_dp1 = 1 -dt * (-2  * a*J2*sin22 - 2 * b*(J2**(3/2))*sin23)
        dg1_dp2 =  -dt * (2 * a*J2*sin22 + 3 * b*(J2**(3/2))*sin23)
        dg2_dp1 = -dt * (-2 * a*J1*sin22 - 3 *b*J1*(J2**(1/2))*sin23)
        dg2_dp2 = 1 -dt * (+2 * a*J1*sin22 + (9/2) *b*J1*(J2**(1/2))*sin23)

        #matriz A
        A = [[dg1_dp1, dg1_dp2],[dg2_dp1, dg2_dp2]]

        #decomposição LU
        u11 = A[0][0]
        l21 = (A[1][0])/u11
        u12 = A[0][1]
        u22 = A[1][1] - l21*u12

        #L = [[1, 0], [l21, 1]] #matriz L

        #U = [[u11, u12], [0, u22]] #matriz U

        #solução do método de newton pelo método LU
        x1 = B[0]

        x2 = B[1] - l21*x1

        q2 = x2/u22

        q1 = (x1 - u12*q2)/u11

        #atualiza as variáveis
        p1_n1 = q1 + p1_n

        p2_n1 = q2 + p2_n

    return p1_n1, p2_n1

def con_iniciais(p1, p2, J2, a, b, E = 0.08333):
    '''
    Calcula J1 por bhaskara a partir da fixação das outras variáveis da hamiloniana
    Parameters
    ----------
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    E : float, opcional
        Energia. O padrão é 0.08333.

    Returns p1, p2, J1, J2
    -------
    '''
    #J**2 - J1*(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2)) + E - J2**2

    #bhaskara
    a_bk = 1
    b_bk = -1* float(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2))
    c_bk = E - J2**2 - J2

    J1 = (-b_bk + ((b_bk*b_bk - 4*a_bk*c_bk)**(1/2)))/(2*a_bk)

    return p1, p2, J1, J2

def henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, u):
    '''
    Calcula o método de Henon para determinar a seção de Poicaré em termos das
    coordenadas de posição e momento

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    dp1 : float
        Derivada temporal de phi1
    dp2 : float
        Derivada temporal de phi2
    dJ1 : float
        Derivada temporal de J1
    dJ2 : float
        Derivada temporal de J2
    a : float
        Parâmetro
    b : float
        Parâmetro
    u : float
        Distância entre o ponto fixado e a seção de poicaré

    Returns q1, q2, m1, m2
    -------
    '''
    #método de henon
    p1 = p1
    p2 += u * (dp2/dp1)
    J1 += u * (dJ1/dp1)
    J2 += u * (dJ2/dp1)

    #cálculo da posição e momento
    q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)
    q2, m2 = ((2*J2)**(1/2))*np.cos(p2), -((2*J2)**(1/2))*np.sin(p2)
    return q1, q2, m1, m2

#parâmetros do EP
a = 0.1
b = 0
E = 0.18

#configuração da interação
dt = 0.005
t_max = 2500

#cores dos gráficos
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k']

#chutes iniciais para J2
iniciaisq = [0.1, 0.25, 0.7,0.4, 0.4, 1.0]#, 0.07, 0.0200, 0.005, 0.0025]#
iniciaisp = [np.pi, np.pi, np.pi, 0,np.pi,np.pi]
iniciaisJ =[]
for i, element in enumerate(iniciaisq):
  iniciaisJ.append((1/2)*((element/(np.cos(iniciaisp[i])))**2))
#controle do tempo de execução
print(iniciaisJ)
start_time_ini = time.time()

#grandezas analisadas no EP
F2 = []
F1 = []
tempo = []
En =[]

#para cada chute inicial
for i in range(0, len(iniciaisJ), 1):
    #cria as listas para armazenar as variáveis de
    En.append([])
    t_henon = []
    lista_henon = []
    q2_henon = []
    m2_henon = []
    q1_list = []

    #checa se J1 é real ou não
    checa = False
    while checa == False:
        p1_n, p2_n, J1_n, J2_n = con_iniciais(3*np.pi/2, iniciaisp[i], iniciaisJ[i], a, b, E)
        if type(J1_n) is not complex and J1_n > 0:
            checa = True

    #mostra quantos porcento foi execultado para cada chute inicial
    ax = None
    for t in np.arange(0, t_max, dt):
        porcent = str(100* t//t_max)

        if porcent != ax:
            print('% = ', 100* t//t_max, '%')
            ax = str(100* t//t_max)

    #uso um try para evitar erros
        try:

          p1, p2 = newton(0, p1_n, 0, p2_n, dt, J1_n, J2_n, a, b, 10**(-13))

          dp1, dp2, dJ1, dJ2 = dH(p1, J1_n, p2, J2_n, a, b, dt)
          J1 = euler(p1_n, J1_n, dp1, dJ1, dt)[1]
          J2 = euler(p2_n, J2_n, dp2, dJ2, dt)[1]
          En[i].append(H_WF(J1, J2, p1, p2, a, b)[0])

          #apenas para a primeira trajetória e para tempo menor que 100, gera os dados para F1 e F2
          if i == 0 and t < 100:
              tempo.append(t)
              F1.append(J1 + J2)
              F2.append(3*J1 + 2*J2)

          #converte os pontos para momento e posição
          q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)

          #se é a primeira interação eu calculo a posição anterior explicitamente
          if t == 0:
              q1_n =  ((2*J1_n)**(1/2))*np.cos(p1_n)

          #atualizado as variáveis para próxima interação
          p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #para checar se está calculando corretamente
          q1_list.append(q1)

          #ALCIDES, ISSO AQUI É O MÉTODO QUE TEM QUE USAR, O DE BAIXO FOI EU METENDO O LOUCO PARA INTERAR MAIS VEZES
          if q1*q1_n < 0 and m1 >= 0:  #Seção de Poincaré no plano p2 x q2
            lista_henon.append(list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/(m1**2 + q1**2))*q1)))
            t_henon.append(t)

          #atualizo q1
          q1_n = q1
          '''
          #método aconchabrado
          if np.abs(q1) < 10**(-2) and m1 >= 0:
              lista_henon.append(list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/(m1**2 + q1**2))*q1)))
              t_henon.append(t)'''

        except:
            continue

    print('saiu') #sinaliza que deu tudo certo

    #armazena o momento e posição para gerar a seção de poicaré
    for element in lista_henon:
      q2_henon.append(element[1])
      m2_henon.append(element[3])

    #plota a seção de poicaré
    plt.figure(1, figsize=(8, 6))
    plt.scatter(q2_henon, m2_henon, color=colors[i], s =0.9)

    #abaixo é para gerar gráficos da energia e verificar se está sendo uma constante de movimento
    '''plt.scatter(tempo, En[i], color=colors[i], s = 0.2)
    plt.ylim(0.16, 0.19)'''

#tempo de execução
end_time_ini = time.time()
timefinal = str((end_time_ini - start_time_ini)//60) + ' minutos e ' + str(round((end_time_ini - start_time_ini)%60,2)) + ' segundos'
print("Essa operação levou {}".format(timefinal))

#parâmetros dos gráficos
plt.title('Seção de Poincaré para E = {0}'.format(E))
plt.xlabel('$q_2$')
plt.ylabel('$p_2$')
plt.grid()
plt.show()

#abaixo cria os gráficos de F1 e F2
#MAS ALGO ESTÁ ERRADO, QUANDO VC USA max(F1) e min(F1) DA PRA VER QUE É UMA CONSTANTE
#DE MOVIMENTO, MAS NO GRÁFICO PARECE QUE NÃO, NÃO ENTENDI O QUE ACONTECEU E NÃO TIVE TEMPO '''acho que agora foi'''
#DE VERIFICAR PARA ARRUMAR
'''
plt.figure(2, figsize=(8, 6))
plt.scatter(tempo, F1, color=colors[i], s = 0.2)
plt.ylim(min(F1)+ 10**(-6), max(F1)- 10**(-6))
plt.xlabel('$t$')
plt.ylabel('$F1$')


plt.figure(3, figsize=(8, 6))
plt.scatter(tempo, F2, color=colors[i], s = 0.2)
plt.ylim( min(F2), max(F2))
plt.xlabel('$t$')
plt.ylabel('$F2$')
plt.show()'''
'''
for j, element in enumerate(En):
    plt.figure(j + 2, figsize=(8, 6))
    plt.scatter(tempo, element, color=colors[j], s = 0.2)
    plt.xlabel('$t$')
    plt.ylabel('$E$')
    plt.grid()
    plt.show()'''



# -*- coding: utf-8 -*-
"""
Created on Fri Oct 27 14:10:59 2023

@author: Gustavo
"""
import numpy as np
import matplotlib.pyplot as plt
import random
import time
import cProfile
import sys
import gc


def H_WF(J1, J2, p1, p2, a, b):
    '''
    Calcula a hamiltoniana de Walker-Ford a partir das variáveis de ângulo e
    ação

    Parameters
    ----------
    J1 : float
        Ação
    J2 : float
        Ação
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    a : float
        Parâmetro
    b : float
        Parâmetro

    Returns
    -------
    H : float
        Hamiltoniana de Walker-Ford
    H_0 : float
        Hamiltoniana não perturbada
    H_1 : float
        Perturbação

    '''

    H_0 = J1 + J2 - J1**2 - 3*J1*J2 + J2**2
    H_1 = a* J1 *J2 * np.cos(2*p1 - 2*p2) + b* J1 * (J2**(3/2))*np.cos(2*p1 - 3*p2)
    H = H_0 + H_1

    return H, H_0, H_1

def dH(p1, J1, p2, J2, a, b, dt):
    '''
    Função que calcula a derivada parcial da hamiltoniana

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    dt : float
        Passo temporal

    Returns : dp1/dt, dp2/dt, dJ1/dt, dJ2/dt
    -------
    '''

    #funções trigonométricas
    cos22 = np.cos(2*p1 - 2*p2)
    cos23 = np.cos(2*p1 -3*p2)
    sin22 = np.sin(2*p1 - 2*p2)
    sin23 = np.sin(2*p1 -3*p2)

    #derivadas temporais
    dp1_dt = 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23
    dp2_dt = 1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23

    dJ1_dt = +2*a*J1*J2*sin22 + 2*b*J1*(J2**(3/2))*sin23
    dJ2_dt = -2*a*J1*J2*sin22 - 3*b*J1*(J2**(3/2))*sin23

    return  dp1_dt, dp2_dt, dJ1_dt, dJ2_dt


def euler(x_n, y_n, dHx, dHy, delta_t):
    '''
    Calcula o método de euler para as variáveis phi e J usando a derivada
    parcial correspondente

    Parameters
    ----------
    x_n : float
        variável integrada
    y_n : float
        variável não integrada
    dHx : float
        derivada parcial da hamiltoniana em função da variável integrada
    dHy : float
        derivada parcial da hamiltoniana em função da variável integrada
    delta_t : float
        passo de tempo para integração

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    y_(n+1) = y_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    -------
    '''
    return x_n + delta_t*dHx, y_n + delta_t*dHy

def newton(p1_n1, p1_ne, p2_n1, p2_ne, dt, J1, J2, a, b, e):
    '''
    Calcula o método de Newton para determinar phi^{n+1}

    Parameters
    ----------
    p1_n1 : float
        Chute para o método de newton.
    p1_ne : float
        Resultado interior da integração numérica.
    p2_n1 : float
        Chute para o método de newton.
    p2_ne : float
        Resultado interior da integração numérica.
    dt : float
        Passo temporal.
    J1 : float
        Variável de ação da integração numérica.
    J2 : float
        Variável de ação da integração numérica.
    a : float
        Parâmetro
    b : float
        Parâmetro
    e : float
        Erro requirido.

    Returns ph1^{n+1}, phi2^{n+2}
    -------
    '''

    while True: #intera indefinidamente

        p1_n = p1_n1
        p2_n = p2_n1

        #funções trignométricas
        cos22 = np.cos(2*p1_n - 2*p2_n)
        cos23 = np.cos(2*p1_n -3*p2_n)
        sin22 = np.sin(2*p1_n - 2*p2_n)
        sin23 = np.sin(2*p1_n -3*p2_n)

        #g1 e g2
        g1 = p1_n - p1_ne - dt * ( 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23)
        g2 = p2_n - p2_ne - dt * (1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23)

        if np.abs(g1) < e or np.abs(g2) < e: #verifica se está menor que o erro aceitável
            break

        B = [-g1, -g2] #matriz B

        #elementos da matriz A
        dg1_dp1 = 1 -dt * (-2  * a*J2*sin22 - 2 * b*(J2**(3/2))*sin23)
        dg1_dp2 =  -dt * (2 * a*J2*sin22 + 3 * b*(J2**(3/2))*sin23)
        dg2_dp1 = -dt * (-2 * a*J1*sin22 - 3 *b*J1*(J2**(1/2))*sin23)
        dg2_dp2 = 1 -dt * (+2 * a*J1*sin22 + (9/2) *b*J1*(J2**(1/2))*sin23)

        #matriz A
        A = [[dg1_dp1, dg1_dp2],[dg2_dp1, dg2_dp2]]

        #decomposição LU
        u11 = A[0][0]
        l21 = (A[1][0])/u11
        u12 = A[0][1]
        u22 = A[1][1] - l21*u12

        #L = [[1, 0], [l21, 1]] #matriz L

        #U = [[u11, u12], [0, u22]] #matriz U

        #solução do método de newton pelo método LU
        x1 = B[0]

        x2 = B[1] - l21*x1

        q2 = x2/u22

        q1 = (x1 - u12*q2)/u11

        #atualiza as variáveis
        p1_n1 = q1 + p1_n

        p2_n1 = q2 + p2_n


        del q1, q2, x1, x2, A, u11, l21, u12, u22
    #gc.collect()

    return p1_n1, p2_n1

def con_iniciais(p1, p2, J2, a, b, E = 0.08333):
    '''
    Calcula J1 por bhaskara a partir da fixação das outras variáveis da hamiloniana
    Parameters
    ----------
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    E : float, opcional
        Energia. O padrão é 0.08333.

    Returns p1, p2, J1, J2
    -------
    '''
    #J**2 - J1*(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2)) + E - J2**2

    #bhaskara
    a_bk = 1
    b_bk = -1* float(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2))
    c_bk = E - J2**2 - J2

    J1 = (-b_bk + ((b_bk*b_bk - 4*a_bk*c_bk)**(1/2)))/(2*a_bk)

    return p1, p2, J1, J2

def henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, u):
    '''
    Calcula o método de Henon para determinar a seção de Poicaré em termos das
    coordenadas de posição e momento

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    dp1 : float
        Derivada temporal de phi1
    dp2 : float
        Derivada temporal de phi2
    dJ1 : float
        Derivada temporal de J1
    dJ2 : float
        Derivada temporal de J2
    a : float
        Parâmetro
    b : float
        Parâmetro
    u : float
        Distância entre o ponto fixado e a seção de poicaré

    Returns q1, q2, m1, m2
    -------
    '''
    #método de henon
    p1 = p1
    p2 += u * (dp2/dp1)
    J1 += u * (dJ1/dp1)
    J2 += u * (dJ2/dp1)

    #cálculo da posição e momento
    q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)
    q2, m2 = ((2*J2)**(1/2))*np.cos(p2), -((2*J2)**(1/2))*np.sin(p2)
    return q1, q2, m1, m2

#parâmetros do EP
a = 0.1
b = 0
E = 0.18

#configuração da interação
dt = 0.01
t_max = 3000

#cores dos gráficos
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k','b', 'g', 'r', 'c', 'm', 'y', 'k']

#chutes iniciais para J2
iniciaisq = [0.3, 0.3, 0.51, 0.05, 0.10, 0.59, 0.25, 0.25, 0.15, 0.20]
iniciaisp = [np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0]
iniciaisJ =[]
for i, element in enumerate(iniciaisq):
  iniciaisJ.append((element/(np.cos(iniciaisp[i])))**2)
#controle do tempo de execução
start_time_ini = time.time()

#grandezas analisadas no EP
F2 = []
F1 = []
tempo = []
En =[]

#para cada chute inicial
for i in range(0, len(iniciaisJ), 1):
    #cria as listas para armazenar as variáveis de
    En.append([])
    t_henon = []
    lista_henon = []
    q2_henon = []
    m2_henon = []
    q1_list = []

    #checa se J1 é real ou não
    checa = False
    while checa == False:
        p1_n, p2_n, J1_n, J2_n = con_iniciais(3*np.pi/2, iniciaisp[i], iniciaisJ[i], a, b, E)
        if type(J1_n) is not complex and J1_n > 0:
            checa = True

    #mostra quantos porcento foi execultado para cada chute inicial
    ax = None
    for t in range(0, round(t_max/dt), 1):
        nb_porcent = 100* t//(t_max/dt)
        porcent = str(nb_porcent)

        if nb_porcent % 10 == 0 and porcent != ax:
            print('% = ', 100*t//(t_max/dt), '%', end = ' ')
            ax = str(100* t//(t_max/dt))

    #uso um try para evitar erros
        try:

          p1, p2 = newton(0, p1_n, 0, p2_n, dt, J1_n, J2_n, a, b, 10**(-4))

          dp1, dp2, dJ1, dJ2 = dH(p1, J1_n, p2, J2_n, a, b, dt)
          J1 = euler(p1_n, J1_n, dp1, dJ1, dt)[1]
          J2 = euler(p2_n, J2_n, dp2, dJ2, dt)[1]
          #print(p1, p2)
          #En[i].append(H_WF(J1, J2, p1, p2, a, b)[0])

          #apenas para a primeira trajetória e para tempo menor que 100, gera os dados para F1 e F2
          '''if i == 0 and t < 100:
              tempo.append(t)
              F1.append(J1 + J2)
              F2.append(3*J1 + 2*J2)'''

          #converte os pontos para momento e posição
          q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)

          #se é a primeira interação eu calculo a posição anterior explicitamente
          if t == 0:
              q1_n =  ((2*J1_n)**(1/2))*np.cos(p1_n)

          #atualizado as variáveis para próxima interação
          p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #print(q1, m1)
          #para checar se está calculando corretamente
          #q1_list.append(q1)

          #ALCIDES, ISSO AQUI É O MÉTODO QUE TEM QUE USAR, O DE BAIXO FOI EU METENDO O LOUCO PARA INTERAR MAIS VEZES
          if q1*q1_n < 0 and m1 >= 0:  #Seção de Poincaré no plano p2 x q2
            tg = np.arctan2(m1, q1)
            if tg < 0:
                tg += 2*np.pi
            q1h, q2h, m1h, m2h = list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/(m1**2 + q1**2))*q1))
            #print(q2h, m2h)
            plt.figure(1, figsize=(8, 6))
            plt.scatter(q2h, m2h, color=colors[i], s = 0.9)
            #T_henon.append(t)

          del  p1, p2, J1, J2, m1
          #atualizo q1
          q1_n = q1

          #(m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)
          #método aconchabrado
          '''if np.abs(q1) < 10**(-1) and m1 >= 0:
              q1h, q2h, m1h, m2h = list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)))
              #print(q2h, m2h)
              plt.figure(1, figsize=(8, 6))
              plt.scatter(q2h, m2h, color=colors[i], s = 0.9)'''

        except:
            continue
    gc.collect()
    print('100%') #sinaliza que deu tudo certo

    #armazena o momento e posição para gerar a seção de poicaré
    '''for element in lista_henon:
      q2_henon.append(element[1])
      m2_henon.append(element[3])'''

    #plota a seção de poicaré


    #abaixo é para gerar gráficos da energia e verificar se está sendo uma constante de movimento
    '''plt.scatter(tempo, En[i], color=colors[i], s = 0.2)
    plt.ylim(0.16, 0.19)'''

#tempo de execução
end_time_ini = time.time()
timefinal = str((end_time_ini - start_time_ini)//60) + ' minutos e ' + str(round((end_time_ini - start_time_ini)%60,2)) + ' segundos'
print("Essa operação levou {}".format(timefinal))

#parâmetros dos gráficos
plt.title('Seção de Poincaré para E = {0}'.format(E))
plt.xlabel('$q_2$')
plt.ylabel('$p_2$')
plt.grid()
plt.show()

#abaixo cria os gráficos de F1 e F2
#MAS ALGO ESTÁ ERRADO, QUANDO VC USA max(F1) e min(F1) DA PRA VER QUE É UMA CONSTANTE
#DE MOVIMENTO, MAS NO GRÁFICO PARECE QUE NÃO, NÃO ENTENDI O QUE ACONTECEU E NÃO TIVE TEMPO '''acho que agora foi'''
#DE VERIFICAR PARA ARRUMAR
'''
plt.figure(2, figsize=(8, 6))
plt.scatter(tempo, F1, color=colors[i], s = 0.2)
plt.ylim(min(F1)+ 10**(-6), max(F1)- 10**(-6))
plt.xlabel('$t$')
plt.ylabel('$F1$')


plt.figure(3, figsize=(8, 6))
plt.scatter(tempo, F2, color=colors[i], s = 0.2)
plt.ylim( min(F2), max(F2))
plt.xlabel('$t$')
plt.ylabel('$F2$')
plt.show()'''
'''
for j, element in enumerate(En):
    plt.figure(j + 2, figsize=(8, 6))
    plt.scatter(tempo, element, color=colors[j], s = 0.2)
    plt.xlabel('$t$')
    plt.ylabel('$E$')
    plt.grid()
    plt.show()'''

A# -*- coding: utf-8 -*-
"""
Created on Sat Oct 28 17:02:16 2023

@author: talgu
"""

# -*- coding: utf-8 -*-
"""
Created on Fri Oct 27 14:10:59 2023

@author: Gustavo
"""
import numpy as np
import matplotlib.pyplot as plt
import time
import sys
import gc


def H_WF(J1, J2, p1, p2, a, b):
    '''
    Calcula a hamiltoniana de Walker-Ford a partir das variáveis de ângulo e
    ação

    Parameters
    ----------
    J1 : float
        Ação
    J2 : float
        Ação
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    a : float
        Parâmetro
    b : float
        Parâmetro

    Returns
    -------
    H : float
        Hamiltoniana de Walker-Ford
    H_0 : float
        Hamiltoniana não perturbada
    H_1 : float
        Perturbação

    '''

    H_0 = J1 + J2 - J1**2 - 3*J1*J2 + J2**2
    H_1 = a* J1 *J2 * np.cos(2*p1 - 2*p2) + b* J1 * (J2**(3/2))*np.cos(2*p1 - 3*p2)
    H = H_0 + H_1

    return H, H_0, H_1

def dH(p1, J1, p2, J2, a, b, dt):
    '''
    Função que calcula a derivada parcial da hamiltoniana

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    dt : float
        Passo temporal

    Returns : dp1/dt, dp2/dt, dJ1/dt, dJ2/dt
    -------
    '''

    #funções trigonométricas
    cos22 = np.cos(2*p1 - 2*p2)
    cos23 = np.cos(2*p1 -3*p2)
    sin22 = np.sin(2*p1 - 2*p2)
    sin23 = np.sin(2*p1 -3*p2)

    #derivadas temporais
    dp1_dt = 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23
    dp2_dt = 1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23

    dJ1_dt = +2*a*J1*J2*sin22 + 2*b*J1*(J2**(3/2))*sin23
    dJ2_dt = -2*a*J1*J2*sin22 - 3*b*J1*(J2**(3/2))*sin23

    return  float(dp1_dt), float(dp2_dt), float(dJ1_dt), float(dJ2_dt)


def euler(x_n, y_n, dHx, dHy, delta_t):
    '''
    Calcula o método de euler para as variáveis phi e J usando a derivada
    parcial correspondente

    Parameters
    ----------
    x_n : float
        variável integrada
    y_n : float
        variável não integrada
    dHx : float
        derivada parcial da hamiltoniana em função da variável integrada
    dHy : float
        derivada parcial da hamiltoniana em função da variável integrada
    delta_t : float
        passo de tempo para integração

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    y_(n+1) = y_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    -------
    '''
    return x_n + delta_t*dHx, y_n + delta_t*dHy

def newton(p1_n1, p1_ne, p2_n1, p2_ne, dt, J1, J2, a, b, e):
    '''
    Calcula o método de Newton para determinar phi^{n+1}

    Parameters
    ----------
    p1_n1 : float
        Chute para o método de newton.
    p1_ne : float
        Resultado interior da integração numérica.
    p2_n1 : float
        Chute para o método de newton.
    p2_ne : float
        Resultado interior da integração numérica.
    dt : float
        Passo temporal.
    J1 : float
        Variável de ação da integração numérica.
    J2 : float
        Variável de ação da integração numérica.
    a : float
        Parâmetro
    b : float
        Parâmetro
    e : float
        Erro requirido.

    Returns ph1^{n+1}, phi2^{n+2}
    -------
    '''

    while True: #intera indefinidamente

        p1_n = p1_n1
        p2_n = p2_n1

        #funções trignométricas
        cos22 = round(np.cos(2*p1_n - 2*p2_n),10)
        cos23 = round(np.cos(2*p1_n -3*p2_n),10)
        sin22 = round(np.sin(2*p1_n - 2*p2_n),10)
        sin23 = round(np.sin(2*p1_n -3*p2_n),10)

        #g1 e g2
        g1 = p1_n - p1_ne - dt * ( 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23)
        g2 = p2_n - p2_ne - dt * (1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23)

        if np.abs(g1) < e or np.abs(g2) < e: #verifica se está menor que o erro aceitável
            break

        B = [-g1, -g2] #matriz B

        #elementos da matriz A
        dg1_dp1 = 1 - dt * ((-2  * a*J2*sin22) - (2 * b*(J2**(3/2))*sin23))
        dg1_dp2 =  -dt * ((2 * a*J2*sin22) + (3 * b*(J2**(3/2))*sin23))
        dg2_dp1 = -dt * ((-2 * a*J1*sin22) - (3 *b*J1*(J2**(1/2))*sin23))
        dg2_dp2 = 1 -dt * ((2 * a*J1*sin22) + ((9/2) *b*J1*(J2**(1/2))*sin23))

        #matriz A
        A = [[dg1_dp1, dg1_dp2],[dg2_dp1, dg2_dp2]]

        #decomposição LU
        u11 = A[0][0]
        l21 = (A[1][0])/u11
        u12 = A[0][1]
        u22 = A[1][1] - l21*u12

        #L = [[1, 0], [l21, 1]] #matriz L

        #U = [[u11, u12], [0, u22]] #matriz U

        #solução do método de newton pelo método LU
        x1 = B[0]

        x2 = B[1] - l21*x1

        q2 = x2/u22

        q1 = (x1 - u12*q2)/u11

        #atualiza as variáveis
        p1_n1 = q1 + p1_n

        p2_n1 = q2 + p2_n


        del q1, q2, x1, x2, A, u11, l21, u12, u22


    return float(p1_n1), float(p2_n1)

def con_iniciais(p1, p2, J2, a, b, E = 0.08333):
    '''
    Calcula J1 por bhaskara a partir da fixação das outras variáveis da hamiloniana
    Parameters
    ----------
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    E : float, opcional
        Energia. O padrão é 0.08333.

    Returns p1, p2, J1, J2
    -------
    '''
    #J**2 - J1*(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2)) + E - J2**2

    #bhaskara
    a_bk = -1
    b_bk = float(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2))
    c_bk = J2**2 + J2 - E

    J1 = (-b_bk - ((b_bk*b_bk - 4*a_bk*c_bk)**(1/2)))/(2*a_bk)

    return float(p1), float(p2), float(J1), float(J2)

def henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, u):
    '''
    Calcula o método de Henon para determinar a seção de Poicaré em termos das
    coordenadas de posição e momento

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    dp1 : float
        Derivada temporal de phi1
    dp2 : float
        Derivada temporal de phi2
    dJ1 : float
        Derivada temporal de J1
    dJ2 : float
        Derivada temporal de J2
    a : float
        Parâmetro
    b : float
        Parâmetro
    u : float
        Distância entre o ponto fixado e a seção de poicaré

    Returns q1, q2, m1, m2
    -------
    '''
    #método de henon
    p1 = p1
    p2 += u * (dp2/dp1)
    J1 += u * (dJ1/dp1)
    J2 += u * (dJ2/dp1)

    #cálculo da posição e momento
    q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)
    q2, m2 = ((2*J2)**(1/2))*np.cos(p2), -((2*J2)**(1/2))*np.sin(p2)
    return float(q1), float(q2), float(m1), float(m2)

#parâmetros do EP
a = 0
b = 0.1
E = 0.18

#configuração da interação
dt = 0.001
t_max = 3000

#cores dos gráficos
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k','b', 'g', 'r', 'c', 'm', 'y', 'k']

#chutes iniciais para J2 e phi2  a partir da variável de pósição
#iniciaisq = [0.38, 0.3175,0.37]#, 0.2, 0.3555, 0.343, 0.3, 0.405, 0.53, 0.7]#, 0.6, 0.8]# 0.15, 0.20]
iniciaisq = [0.1, 0.3555, 0.3, 0.3175, 0.38, 0.4, 0.425, 0.5 ]#, 0.45, 0.5, 0.55]

iniciaisp = [np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0]
iniciaisJ =[]
for i, element in enumerate(iniciaisq):
    if round(np.cos(iniciaisp[i]), 10) != 0.0:
        iniciaisJ.append((element/(round(np.cos(iniciaisp[i]), 10)))**2)
    else:
        iniciaisJ.append(0)

#controle do tempo de execução
start_time_ini = time.time()

#grandezas analisadas no EP
F2 = []
F1 = []
tempo = []
En =[]

#para cada chute inicial
for i in range(0, len(iniciaisJ), 1):
    #cria as listas para armazenar as variáveis de
    t_henon = []
    lista_henon = []
    q2_henon = []
    m2_henon = []
    q1_list = []

    #checa se J1 é real ou não
    checa = False
    while checa == False:
        #define as condições iniciais e printa para verificarmos se está condizente com a energia do problema
        p1_n, p2_n, J1_n, J2_n = con_iniciais(3*np.pi/2, iniciaisp[i], iniciaisJ[i], a, b, E)
        print(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0])
        if 'nan' in str(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0]):
            sys.exit()


        if type(J1_n) is not complex:
            checa = True


    ax = None
    for t in range(0, round(t_max/dt), 1):

        #printa de 10 em 10% para cada trajetória
        nb_porcent = 100* t//(t_max/dt)
        porcent = str(nb_porcent)

        if nb_porcent % 10 == 0 and porcent != ax:
            print('% = ', 100*t//(t_max/dt), '%', end = ' ')
            ax = str(100* t//(t_max/dt))

    #uso um try para evitar erros
        try:
          #determino phi1 e phi2 pelo método de newton
          p1, p2 = newton(3*np.pi/2, p1_n, iniciaisp[i], p2_n, dt, J1_n, J2_n, a, b, 10**(-9))

          #calculo a derivada temporal para os pontos atualizados
          dp1, dp2, dJ1, dJ2 = dH(p1, J1_n, p2, J2_n, a, b, dt)

          #calculo o método de euler simplético para a ação
          J1 = euler(p1, J1_n, dp1, dJ1, dt)[1]
          J2 = euler(p2, J2_n, dp2, dJ2, dt)[1]


          #En[i].append(H_WF(J1, J2, p1, p2, a, b)[0])

          #apenas para a primeira trajetória, gera os dados para F1 e F2
          if i == 0:
              tempo.append(t*dt)
              F1.append(float(J1 + J2))
              F2.append(float(3*J1 + 2*J2))
              En.append(float(H_WF(J1, J2, p1, p2, a, b)[0]))
          #converte os pontos para momento e posição
          q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)

          #se é a primeira interação eu calculo a posição anterior explicitamente
          if t == 0:
              q1_n =  ((2*J1_n)**(1/2))*np.cos(p1_n)



          if q1*q1_n < 0 and m1 > 0:  #Seção de Poincaré no plano p2 x q2
            dp1_n, dp2_n, dJ1_n, dJ2_n = dH(p1_n, J1_n, p2_n, J2_n, a, b, dt)
            m1_n = -((2*J1_n)**(1/2))*np.sin(p1_n)
            q1h, q2h, m1h, m2h = list(henon(p1_n, J1_n, p2_n, J2_n, dp1_n, dp2_n, dJ1_n, dJ2_n, a, b, dt, -(m1_n/(m1_n**2 + q1_n**2))*q1_n))#(m1/(m1**2 + q1**2))*q1))

            plt.figure(1, figsize=(8, 6))
            plt.scatter(q2h, m2h, color=colors[i], s = 0.9)


          p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #atualizo q1
          q1_n = q1


        except:
            continue
    gc.collect()
    print('100%') #sinaliza que deu tudo certo

#tempo de execução
end_time_ini = time.time()
timefinal = str((end_time_ini - start_time_ini)//60) + ' minutos e ' + str(round((end_time_ini - start_time_ini)%60,2)) + ' segundos'
print("Essa operação levou {}".format(timefinal))

#parâmetros dos gráficos
plt.title('Seção de Poincaré para E = {0}'.format(E))
plt.xlabel('$q_2$')
plt.ylabel('$p_2$')
plt.grid()


#gráficos de F1, F2 e E
'''
plt.figure(2, figsize=(8, 6))
plt.subplot(3, 1, 1)
plt.plot(tempo, F1, color=colors[i])#, s = 0.2)
plt.ylim(min(F1)*0.95, max(F1)*(1.05))
plt.xlabel('$t$')
plt.ylabel('$F_1$')
plt.grid()
plt.title(r"Energia, F1 e F2 em função do tempo para E = {0}, a = {1} e b = {2}".format(E, a, b))


plt.figure(2, figsize=(8, 6))
plt.subplot(3, 1, 2)
plt.plot(tempo, F2, color=colors[i])
plt.ylim(min(F2)*0.95, max(F2)*(1.05))
plt.xlabel('$t$')
plt.ylabel('$F_2$')
plt.grid()

plt.figure(2, figsize=(8, 6))
plt.subplot(3, 1, 3)
plt.plot(tempo, En, color=colors[i])
plt.ylim(min(En)*0.99,  max(En)*(1.01))
#plt.axis([min(tempo), max(tempo), 1.78, 1.81])
plt.xlabel('$t$')
plt.ylabel('$E$')
plt.grid()
plt.show()'''

# -*- coding: utf-8 -*-
"""
Created on Sat Oct 28 17:02:16 2023

@author: talgu
"""

# -*- coding: utf-8 -*-
"""
Created on Fri Oct 27 14:10:59 2023

@author: Gustavo
"""
import numpy as np
import matplotlib.pyplot as plt
import random
import time
import cProfile
import sys
import gc


def H_WF(J1, J2, p1, p2, a, b):
    '''
    Calcula a hamiltoniana de Walker-Ford a partir das variáveis de ângulo e
    ação

    Parameters
    ----------
    J1 : float
        Ação
    J2 : float
        Ação
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    a : float
        Parâmetro
    b : float
        Parâmetro

    Returns
    -------
    H : float
        Hamiltoniana de Walker-Ford
    H_0 : float
        Hamiltoniana não perturbada
    H_1 : float
        Perturbação

    '''

    H_0 = J1 + J2 - J1**2 - 3*J1*J2 + J2**2
    H_1 = a* J1 *J2 * np.cos(2*p1 - 2*p2) + b* J1 * (J2**(3/2))*np.cos(2*p1 - 3*p2)
    H = H_0 + H_1

    return H, H_0, H_1

def dH(p1, J1, p2, J2, a, b, dt):
    '''
    Função que calcula a derivada parcial da hamiltoniana

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    dt : float
        Passo temporal

    Returns : dp1/dt, dp2/dt, dJ1/dt, dJ2/dt
    -------
    '''

    #funções trigonométricas
    cos22 = np.cos(2*p1 - 2*p2)
    cos23 = np.cos(2*p1 -3*p2)
    sin22 = np.sin(2*p1 - 2*p2)
    sin23 = np.sin(2*p1 -3*p2)

    #derivadas temporais
    dp1_dt = 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23
    dp2_dt = 1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23

    dJ1_dt = +2*a*J1*J2*sin22 + 2*b*J1*(J2**(3/2))*sin23
    dJ2_dt = -2*a*J1*J2*sin22 - 3*b*J1*(J2**(3/2))*sin23

    return  dp1_dt, dp2_dt, dJ1_dt, dJ2_dt


def euler(x_n, y_n, dHx, dHy, delta_t):
    '''
    Calcula o método de euler para as variáveis phi e J usando a derivada
    parcial correspondente

    Parameters
    ----------
    x_n : float
        variável integrada
    y_n : float
        variável não integrada
    dHx : float
        derivada parcial da hamiltoniana em função da variável integrada
    dHy : float
        derivada parcial da hamiltoniana em função da variável integrada
    delta_t : float
        passo de tempo para integração

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    y_(n+1) = y_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    -------
    '''
    return x_n + delta_t*dHx, y_n + delta_t*dHy

def newton(p1_n1, p1_ne, p2_n1, p2_ne, dt, J1, J2, a, b, e):
    '''
    Calcula o método de Newton para determinar phi^{n+1}

    Parameters
    ----------
    p1_n1 : float
        Chute para o método de newton.
    p1_ne : float
        Resultado interior da integração numérica.
    p2_n1 : float
        Chute para o método de newton.
    p2_ne : float
        Resultado interior da integração numérica.
    dt : float
        Passo temporal.
    J1 : float
        Variável de ação da integração numérica.
    J2 : float
        Variável de ação da integração numérica.
    a : float
        Parâmetro
    b : float
        Parâmetro
    e : float
        Erro requirido.

    Returns ph1^{n+1}, phi2^{n+2}
    -------
    '''

    while True: #intera indefinidamente

        p1_n = p1_n1
        p2_n = p2_n1

        #funções trignométricas
        cos22 = round(np.cos(2*p1_n - 2*p2_n),10)
        cos23 = round(np.cos(2*p1_n -3*p2_n),10)
        sin22 = round(np.sin(2*p1_n - 2*p2_n),10)
        sin23 = round(np.sin(2*p1_n -3*p2_n),10)

        #g1 e g2
        g1 = p1_n - p1_ne - dt * ( 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23)
        g2 = p2_n - p2_ne - dt * (1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23)

        if np.abs(g1) < e or np.abs(g2) < e: #verifica se está menor que o erro aceitável
            break

        B = [-g1, -g2] #matriz B

        #elementos da matriz A
        dg1_dp1 = 1 -dt * ((-2  * a*J2*sin22) - (2 * b*(J2**(3/2))*sin23))
        dg1_dp2 =  -dt * ((2 * a*J2*sin22) + (3 * b*(J2**(3/2))*sin23))
        dg2_dp1 = -dt * ((-2 * a*J1*sin22) - (3 *b*J1*(J2**(1/2))*sin23))
        dg2_dp2 = 1 -dt * ((2 * a*J1*sin22) + ((9/2) *b*J1*(J2**(1/2))*sin23))

        #matriz A
        A = [[dg1_dp1, dg1_dp2],[dg2_dp1, dg2_dp2]]

        #decomposição LU
        u11 = A[0][0]
        l21 = (A[1][0])/u11
        u12 = A[0][1]
        u22 = A[1][1] - l21*u12

        #L = [[1, 0], [l21, 1]] #matriz L

        #U = [[u11, u12], [0, u22]] #matriz U

        #solução do método de newton pelo método LU
        x1 = B[0]

        x2 = B[1] - l21*x1

        q2 = x2/u22

        q1 = (x1 - u12*q2)/u11

        #atualiza as variáveis
        p1_n1 = q1 + p1_n

        p2_n1 = q2 + p2_n


        del q1, q2, x1, x2, A, u11, l21, u12, u22
    #gc.collect()

    return p1_n1, p2_n1

def con_iniciais(p1, p2, J2, a, b, E = 0.08333):
    '''
    Calcula J1 por bhaskara a partir da fixação das outras variáveis da hamiloniana
    Parameters
    ----------
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    E : float, opcional
        Energia. O padrão é 0.08333.

    Returns p1, p2, J1, J2
    -------
    '''
    #J**2 - J1*(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2)) + E - J2**2

    #bhaskara
    a_bk = -1
    b_bk = float(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2))
    c_bk = J2**2 + J2 - E

    J1 = (-b_bk - ((b_bk*b_bk - 4*a_bk*c_bk)**(1/2)))/(2*a_bk)

    return p1, p2, J1, J2

def henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, u):
    '''
    Calcula o método de Henon para determinar a seção de Poicaré em termos das
    coordenadas de posição e momento

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    dp1 : float
        Derivada temporal de phi1
    dp2 : float
        Derivada temporal de phi2
    dJ1 : float
        Derivada temporal de J1
    dJ2 : float
        Derivada temporal de J2
    a : float
        Parâmetro
    b : float
        Parâmetro
    u : float
        Distância entre o ponto fixado e a seção de poicaré

    Returns q1, q2, m1, m2
    -------
    '''
    #método de henon
    p1 = p1
    p2 += u * (dp2/dp1)
    J1 += u * (dJ1/dp1)
    J2 += u * (dJ2/dp1)

    #cálculo da posição e momento
    q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)
    q2, m2 = ((2*J2)**(1/2))*np.cos(p2), -((2*J2)**(1/2))*np.sin(p2)
    return q1, q2, m1, m2

#parâmetros do EP
a = 0.02
b = 0.02
E = 0.0561

#configuração da interação
dt = 0.1
t_max = 5000

#cores dos gráficos
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k','b', 'g', 'r', 'c', 'm', 'y', 'k']

#chutes iniciais para J2
iniciaisq = [0.1, 0.25, 0.365, 0.39, 0.373, 0.5, 0.55, 0.7, 0.8]# 0.15, 0.20
#iniciaisq
#iniciaisq = [0.33, 0.33]#, 0.33, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4 #, 0.90, 1.1, 0.5, 0.55, 0.7, 0.8]
iniciaisp = [np.pi, 0, np.pi, np.pi, np.pi, 0, np.pi, 0, np.pi, 0]
iniciaisJ =[]
for i, element in enumerate(iniciaisq):
    if round(np.cos(iniciaisp[i]), 10) != 0.0:
        iniciaisJ.append((element/(round(np.cos(iniciaisp[i]), 10)))**2)
    else:
        iniciaisJ.append(0)
#controle do tempo de execução
start_time_ini = time.time()

#grandezas analisadas no EP
F2 = []
F1 = []
tempo = []
En =[]

#para cada chute inicial
for i in range(0, len(iniciaisJ), 1):
    #cria as listas para armazenar as variáveis de
    En.append([])
    t_henon = []
    lista_henon = []
    q2_henon = []
    m2_henon = []
    q1_list = []

    #checa se J1 é real ou não
    checa = False
    while checa == False:
        p1_n, p2_n, J1_n, J2_n = con_iniciais(3*np.pi/2, iniciaisp[i], iniciaisJ[i], a, b, E)
        print(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0])
        if 'nan' in str(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0]):
            sys.exit()
        #print(J1_n, J2_n, p1_n, p2_n)

        if type(J1_n) is not complex:
            checa = True

    #mostra quantos porcento foi execultado para cada chute inicial
    ax = None
    for t in range(0, round(t_max/dt), 1):
        #print(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0])
        nb_porcent = 100* t//(t_max/dt)
        porcent = str(nb_porcent)

        if nb_porcent % 10 == 0 and porcent != ax:
            print('% = ', 100*t//(t_max/dt), '%', end = ' ')
            ax = str(100* t//(t_max/dt))

    #uso um try para evitar erros
        try:

          p1, p2 = newton(3*np.pi/2, p1_n, iniciaisp[i], p2_n, dt, J1_n, J2_n, a, b, 10**(-7))

          dp1, dp2, dJ1, dJ2 = dH(p1, J1_n, p2, J2_n, a, b, dt)
          J1 = euler(p1, J1_n, dp1, dJ1, dt)[1]
          J2 = euler(p2, J2_n, dp2, dJ2, dt)[1]


          #En[i].append(H_WF(J1, J2, p1, p2, a, b)[0])

          #apenas para a primeira trajetória e para tempo menor que 100, gera os dados para F1 e F2
          '''if i == 0 and t < 100:
              tempo.append(t)
              F1.append(J1 + J2)
              F2.append(3*J1 + 2*J2)'''

          #converte os pontos para momento e posição
          q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)

          #se é a primeira interação eu calculo a posição anterior explicitamente
          if t == 0:
              q1_n =  ((2*J1_n)**(1/2))*np.cos(p1_n)

          #atualizado as variáveis para próxima interação
          #p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #print(q1, m1)
          #para checar se está calculando corretamente
          #q1_list.append(q1)

          #ALCIDES, ISSO AQUI É O MÉTODO QUE TEM QUE USAR, O DE BAIXO FOI EU METENDO O LOUCO PARA INTERAR MAIS VEZES
          if q1*q1_n < 0 and m1 > 0:  #Seção de Poincaré no plano p2 x q2
            dp1_n, dp2_n, dJ1_n, dJ2_n = dH(p1_n, J1_n, p2_n, J2_n, a, b, dt)
            m1_n = -((2*J1_n)**(1/2))*np.sin(p1_n)
            q1h, q2h, m1h, m2h = list(henon(p1_n, J1_n, p2_n, J2_n, dp1_n, dp2_n, dJ1_n, dJ2_n, a, b, dt, (m1/(m1**2 + q1**2))*q1))
            #print(q2h, m2h)
            plt.figure(1, figsize=(8, 6))
            plt.scatter(q2h, m2h, color=colors[i], s= 0.9)
            #T_henon.append(t)'''

          p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #atualizo q1
          q1_n = q1

          #(m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)
          #método aconchabrado
          '''if np.abs(q1) < 10**(-2) and m1 >= 0:
              q2h = ((2*J2)**(1/2))*np.cos(p2)
              m2h = -((2*J2)**(1/2))*np.sin(p2)
              #q1h, q2h, m1h, m2h = list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)))
              #print(q2h, m2h)
              plt.figure(1, figsize=(8, 6))
              plt.scatter(q2h, m2h, color=colors[i], s = 1.1)'''


        except:
            continue
    gc.collect()
    print('100%') #sinaliza que deu tudo certo

    #armazena o momento e posição para gerar a seção de poicaré
    '''for element in lista_henon:
      q2_henon.append(element[1])
      m2_henon.append(element[3])'''

    #plota a seção de poicaré


    #abaixo é para gerar gráficos da energia e verificar se está sendo uma constante de movimento
    '''plt.scatter(tempo, En[i], color=colors[i], s = 0.2)
    plt.ylim(0.16, 0.19)'''

#tempo de execução
end_time_ini = time.time()
timefinal = str((end_time_ini - start_time_ini)//60) + ' minutos e ' + str(round((end_time_ini - start_time_ini)%60,2)) + ' segundos'
print("Essa operação levou {}".format(timefinal))

#parâmetros dos gráficos
plt.title('Seção de Poincaré para E = {0}'.format(E))
plt.xlabel('$q_2$')
plt.ylabel('$p_2$')
plt.grid()
plt.show()

#abaixo cria os gráficos de F1 e F2
#MAS ALGO ESTÁ ERRADO, QUANDO VC USA max(F1) e min(F1) DA PRA VER QUE É UMA CONSTANTE
#DE MOVIMENTO, MAS NO GRÁFICO PARECE QUE NÃO, NÃO ENTENDI O QUE ACONTECEU E NÃO TIVE TEMPO '''acho que agora foi'''
#DE VERIFICAR PARA ARRUMAR
'''
plt.figure(2, figsize=(8, 6))
plt.scatter(tempo, F1, color=colors[i], s = 0.2)
plt.ylim(min(F1)+ 10**(-6), max(F1)- 10**(-6))
plt.xlabel('$t$')
plt.ylabel('$F1$')


plt.figure(3, figsize=(8, 6))
plt.scatter(tempo, F2, color=colors[i], s = 0.2)
plt.ylim( min(F2), max(F2))
plt.xlabel('$t$')
plt.ylabel('$F2$')
plt.show()'''
'''
for j, element in enumerate(En):
    plt.figure(j + 2, figsize=(8, 6))
    plt.scatter(tempo, element, color=colors[j], s = 0.2)
    plt.xlabel('$t$')
    plt.ylabel('$E$')
    plt.grid()
    plt.show()'''

# -*- coding: utf-8 -*-
"""
Created on Sat Oct 28 17:02:16 2023

@author: talgu
"""

# -*- coding: utf-8 -*-
"""
Created on Fri Oct 27 14:10:59 2023

@author: Gustavo
"""
import numpy as np
import matplotlib.pyplot as plt
import random
import time
import cProfile
import sys
import gc


def H_WF(J1, J2, p1, p2, a, b):
    '''
    Calcula a hamiltoniana de Walker-Ford a partir das variáveis de ângulo e
    ação

    Parameters
    ----------
    J1 : float
        Ação
    J2 : float
        Ação
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    a : float
        Parâmetro
    b : float
        Parâmetro

    Returns
    -------
    H : float
        Hamiltoniana de Walker-Ford
    H_0 : float
        Hamiltoniana não perturbada
    H_1 : float
        Perturbação

    '''

    H_0 = J1 + J2 - J1**2 - 3*J1*J2 + J2**2
    H_1 = a* J1 *J2 * np.cos(2*p1 - 2*p2) + b* J1 * (J2**(3/2))*np.cos(2*p1 - 3*p2)
    H = H_0 + H_1

    return H, H_0, H_1

def dH(p1, J1, p2, J2, a, b, dt):
    '''
    Função que calcula a derivada parcial da hamiltoniana

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    dt : float
        Passo temporal

    Returns : dp1/dt, dp2/dt, dJ1/dt, dJ2/dt
    -------
    '''

    #funções trigonométricas
    cos22 = np.cos(2*p1 - 2*p2)
    cos23 = np.cos(2*p1 -3*p2)
    sin22 = np.sin(2*p1 - 2*p2)
    sin23 = np.sin(2*p1 -3*p2)

    #derivadas temporais
    dp1_dt = 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23
    dp2_dt = 1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23

    dJ1_dt = +2*a*J1*J2*sin22 + 2*b*J1*(J2**(3/2))*sin23
    dJ2_dt = -2*a*J1*J2*sin22 - 3*b*J1*(J2**(3/2))*sin23

    return  dp1_dt, dp2_dt, dJ1_dt, dJ2_dt


def euler(x_n, y_n, dHx, dHy, delta_t):
    '''
    Calcula o método de euler para as variáveis phi e J usando a derivada
    parcial correspondente

    Parameters
    ----------
    x_n : float
        variável integrada
    y_n : float
        variável não integrada
    dHx : float
        derivada parcial da hamiltoniana em função da variável integrada
    dHy : float
        derivada parcial da hamiltoniana em função da variável integrada
    delta_t : float
        passo de tempo para integração

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    y_(n+1) = y_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    -------
    '''
    return x_n + delta_t*dHx, y_n + delta_t*dHy

def newton(p1_n1, p1_ne, p2_n1, p2_ne, dt, J1, J2, a, b, e):
    '''
    Calcula o método de Newton para determinar phi^{n+1}

    Parameters
    ----------
    p1_n1 : float
        Chute para o método de newton.
    p1_ne : float
        Resultado interior da integração numérica.
    p2_n1 : float
        Chute para o método de newton.
    p2_ne : float
        Resultado interior da integração numérica.
    dt : float
        Passo temporal.
    J1 : float
        Variável de ação da integração numérica.
    J2 : float
        Variável de ação da integração numérica.
    a : float
        Parâmetro
    b : float
        Parâmetro
    e : float
        Erro requirido.

    Returns ph1^{n+1}, phi2^{n+2}
    -------
    '''

    while True: #intera indefinidamente

        p1_n = p1_n1
        p2_n = p2_n1

        #funções trignométricas
        cos22 = round(np.cos(2*p1_n - 2*p2_n),10)
        cos23 = round(np.cos(2*p1_n -3*p2_n),10)
        sin22 = round(np.sin(2*p1_n - 2*p2_n),10)
        sin23 = round(np.sin(2*p1_n -3*p2_n),10)

        #g1 e g2
        g1 = p1_n - p1_ne - dt * ( 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23)
        g2 = p2_n - p2_ne - dt * (1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23)

        if np.abs(g1) < e or np.abs(g2) < e: #verifica se está menor que o erro aceitável
            break

        B = [-g1, -g2] #matriz B

        #elementos da matriz A
        dg1_dp1 = 1 -dt * ((-2  * a*J2*sin22) - (2 * b*(J2**(3/2))*sin23))
        dg1_dp2 =  -dt * ((2 * a*J2*sin22) + (3 * b*(J2**(3/2))*sin23))
        dg2_dp1 = -dt * ((-2 * a*J1*sin22) - (3 *b*J1*(J2**(1/2))*sin23))
        dg2_dp2 = 1 -dt * ((2 * a*J1*sin22) + ((9/2) *b*J1*(J2**(1/2))*sin23))

        #matriz A
        A = [[dg1_dp1, dg1_dp2],[dg2_dp1, dg2_dp2]]

        #decomposição LU
        u11 = A[0][0]
        l21 = (A[1][0])/u11
        u12 = A[0][1]
        u22 = A[1][1] - l21*u12

        #L = [[1, 0], [l21, 1]] #matriz L

        #U = [[u11, u12], [0, u22]] #matriz U

        #solução do método de newton pelo método LU
        x1 = B[0]

        x2 = B[1] - l21*x1

        q2 = x2/u22

        q1 = (x1 - u12*q2)/u11

        #atualiza as variáveis
        p1_n1 = q1 + p1_n

        p2_n1 = q2 + p2_n


        del q1, q2, x1, x2, A, u11, l21, u12, u22
    #gc.collect()

    return p1_n1, p2_n1

def con_iniciais(p1, p2, J2, a, b, E = 0.08333):
    '''
    Calcula J1 por bhaskara a partir da fixação das outras variáveis da hamiloniana
    Parameters
    ----------
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    E : float, opcional
        Energia. O padrão é 0.08333.

    Returns p1, p2, J1, J2
    -------
    '''
    #J**2 - J1*(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2)) + E - J2**2

    #bhaskara
    a_bk = -1
    b_bk = float(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2))
    c_bk = J2**2 + J2 - E

    J1 = (-b_bk - ((b_bk*b_bk - 4*a_bk*c_bk)**(1/2)))/(2*a_bk)

    return p1, p2, J1, J2

def henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, u):
    '''
    Calcula o método de Henon para determinar a seção de Poicaré em termos das
    coordenadas de posição e momento

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    dp1 : float
        Derivada temporal de phi1
    dp2 : float
        Derivada temporal de phi2
    dJ1 : float
        Derivada temporal de J1
    dJ2 : float
        Derivada temporal de J2
    a : float
        Parâmetro
    b : float
        Parâmetro
    u : float
        Distância entre o ponto fixado e a seção de poicaré

    Returns q1, q2, m1, m2
    -------
    '''
    #método de henon
    p1 = p1
    p2 += u * (dp2/dp1)
    J1 += u * (dJ1/dp1)
    J2 += u * (dJ2/dp1)

    #cálculo da posição e momento
    q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)
    q2, m2 = ((2*J2)**(1/2))*np.cos(p2), -((2*J2)**(1/2))*np.sin(p2)
    return q1, q2, m1, m2

#parâmetros do EP
a = 0.02
b = 0.02
E = 0.2

#configuração da interação
dt = 0.1
t_max = 5000


#cores dos gráficos
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k','b', 'g', 'r', 'c', 'm', 'y', 'k']

#chutes iniciais para J2
iniciaisq = [0.1, 0.25, 0.37, 0.405, 0.43, 0.45, 0.6, 0.8]# 0.15, 0.20]
#iniciaisq = [0.43, 0.45 ]#, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4] #, 0.90, 1.1, 0.5, 0.55, 0.7, 0.8]
iniciaisp = [np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0]
iniciaisJ =[]
for i, element in enumerate(iniciaisq):
    if round(np.cos(iniciaisp[i]), 10) != 0.0:
        iniciaisJ.append((element/(round(np.cos(iniciaisp[i]), 10)))**2)
    else:
        iniciaisJ.append(0)
#controle do tempo de execução
start_time_ini = time.time()

#grandezas analisadas no EP
F2 = []
F1 = []
tempo = []
En =[]

#para cada chute inicial
for i in range(0, len(iniciaisJ), 1):
    #cria as listas para armazenar as variáveis de
    En.append([])
    t_henon = []
    lista_henon = []
    q2_henon = []
    m2_henon = []
    q1_list = []

    #checa se J1 é real ou não
    checa = False
    while checa == False:
        p1_n, p2_n, J1_n, J2_n = con_iniciais(3*np.pi/2, iniciaisp[i], iniciaisJ[i], a, b, E)
        print(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0])
        if 'nan' in str(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0]):
            sys.exit()
        #print(J1_n, J2_n, p1_n, p2_n)

        if type(J1_n) is not complex:
            checa = True

    #mostra quantos porcento foi execultado para cada chute inicial
    ax = None
    for t in range(0, round(t_max/dt), 1):
        #print(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0])
        nb_porcent = 100* t//(t_max/dt)
        porcent = str(nb_porcent)

        if nb_porcent % 10 == 0 and porcent != ax:
            print('% = ', 100*t//(t_max/dt), '%', end = ' ')
            ax = str(100* t//(t_max/dt))

    #uso um try para evitar erros
        try:

          p1, p2 = newton(3*np.pi/2, p1_n, iniciaisp[i], p2_n, dt, J1_n, J2_n, a, b, 10**(-7))

          dp1, dp2, dJ1, dJ2 = dH(p1, J1_n, p2, J2_n, a, b, dt)
          J1 = euler(p1, J1_n, dp1, dJ1, dt)[1]
          J2 = euler(p2, J2_n, dp2, dJ2, dt)[1]


          #En[i].append(H_WF(J1, J2, p1, p2, a, b)[0])

          #apenas para a primeira trajetória e para tempo menor que 100, gera os dados para F1 e F2
          '''if i == 0 and t < 100:
              tempo.append(t)
              F1.append(J1 + J2)
              F2.append(3*J1 + 2*J2)'''

          #converte os pontos para momento e posição
          q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)

          #se é a primeira interação eu calculo a posição anterior explicitamente
          if t == 0:
              q1_n =  ((2*J1_n)**(1/2))*np.cos(p1_n)

          #atualizado as variáveis para próxima interação
          #p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #print(q1, m1)
          #para checar se está calculando corretamente
          #q1_list.append(q1)

          #ALCIDES, ISSO AQUI É O MÉTODO QUE TEM QUE USAR, O DE BAIXO FOI EU METENDO O LOUCO PARA INTERAR MAIS VEZES
          if q1*q1_n < 0 and m1 > 0:  #Seção de Poincaré no plano p2 x q2
            dp1_n, dp2_n, dJ1_n, dJ2_n = dH(p1_n, J1_n, p2_n, J2_n, a, b, dt)
            m1_n = -((2*J1_n)**(1/2))*np.sin(p1_n)
            q1h, q2h, m1h, m2h = list(henon(p1_n, J1_n, p2_n, J2_n, dp1_n, dp2_n, dJ1_n, dJ2_n, a, b, dt, (m1/(m1**2 + q1**2))*q1))
            #print(q2h, m2h)
            plt.figure(1, figsize=(8, 6))
            plt.scatter(q2h, m2h, color=colors[i], s = 0.9)
            #T_henon.append(t)'''

          p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #atualizo q1
          q1_n = q1

          #(m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)
          #método aconchabrado
          '''if np.abs(q1) < 10**(-2) and m1 >= 0:
              q2h = ((2*J2)**(1/2))*np.cos(p2)
              m2h = -((2*J2)**(1/2))*np.sin(p2)
              #q1h, q2h, m1h, m2h = list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)))
              #print(q2h, m2h)
              plt.figure(1, figsize=(8, 6))
              plt.scatter(q2h, m2h, color=colors[i], s = 1.1)'''


        except:
            continue
    gc.collect()
    print('100%') #sinaliza que deu tudo certo

    #armazena o momento e posição para gerar a seção de poicaré
    '''for element in lista_henon:
      q2_henon.append(element[1])
      m2_henon.append(element[3])'''

    #plota a seção de poicaré


    #abaixo é para gerar gráficos da energia e verificar se está sendo uma constante de movimento
    '''plt.scatter(tempo, En[i], color=colors[i], s = 0.2)
    plt.ylim(0.16, 0.19)'''

#tempo de execução
end_time_ini = time.time()
timefinal = str((end_time_ini - start_time_ini)//60) + ' minutos e ' + str(round((end_time_ini - start_time_ini)%60,2)) + ' segundos'
print("Essa operação levou {}".format(timefinal))

#parâmetros dos gráficos
plt.title('Seção de Poincaré para E = {0}'.format(E))
plt.xlabel('$q_2$')
plt.ylabel('$p_2$')
plt.grid()
plt.show()

#abaixo cria os gráficos de F1 e F2
#MAS ALGO ESTÁ ERRADO, QUANDO VC USA max(F1) e min(F1) DA PRA VER QUE É UMA CONSTANTE
#DE MOVIMENTO, MAS NO GRÁFICO PARECE QUE NÃO, NÃO ENTENDI O QUE ACONTECEU E NÃO TIVE TEMPO '''acho que agora foi'''
#DE VERIFICAR PARA ARRUMAR
'''
plt.figure(2, figsize=(8, 6))
plt.scatter(tempo, F1, color=colors[i], s = 0.2)
plt.ylim(min(F1)+ 10**(-6), max(F1)- 10**(-6))
plt.xlabel('$t$')
plt.ylabel('$F1$')


plt.figure(3, figsize=(8, 6))
plt.scatter(tempo, F2, color=colors[i], s = 0.2)
plt.ylim( min(F2), max(F2))
plt.xlabel('$t$')
plt.ylabel('$F2$')
plt.show()'''
'''
for j, element in enumerate(En):
    plt.figure(j + 2, figsize=(8, 6))
    plt.scatter(tempo, element, color=colors[j], s = 0.2)
    plt.xlabel('$t$')
    plt.ylabel('$E$')
    plt.grid()
    plt.show()'''

# -*- coding: utf-8 -*-
"""
Created on Sat Oct 28 17:02:16 2023

@author: talgu
"""

# -*- coding: utf-8 -*-
"""
Created on Fri Oct 27 14:10:59 2023

@author: Gustavo
"""
import numpy as np
import matplotlib.pyplot as plt
import random
import time
import cProfile
import sys
import gc


def H_WF(J1, J2, p1, p2, a, b):
    '''
    Calcula a hamiltoniana de Walker-Ford a partir das variáveis de ângulo e
    ação

    Parameters
    ----------
    J1 : float
        Ação
    J2 : float
        Ação
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    a : float
        Parâmetro
    b : float
        Parâmetro

    Returns
    -------
    H : float
        Hamiltoniana de Walker-Ford
    H_0 : float
        Hamiltoniana não perturbada
    H_1 : float
        Perturbação

    '''

    H_0 = J1 + J2 - J1**2 - 3*J1*J2 + J2**2
    H_1 = a* J1 *J2 * np.cos(2*p1 - 2*p2) + b* J1 * (J2**(3/2))*np.cos(2*p1 - 3*p2)
    H = H_0 + H_1

    return H, H_0, H_1

def dH(p1, J1, p2, J2, a, b, dt):
    '''
    Função que calcula a derivada parcial da hamiltoniana

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    dt : float
        Passo temporal

    Returns : dp1/dt, dp2/dt, dJ1/dt, dJ2/dt
    -------
    '''

    #funções trigonométricas
    cos22 = np.cos(2*p1 - 2*p2)
    cos23 = np.cos(2*p1 -3*p2)
    sin22 = np.sin(2*p1 - 2*p2)
    sin23 = np.sin(2*p1 -3*p2)

    #derivadas temporais
    dp1_dt = 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23
    dp2_dt = 1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23

    dJ1_dt = +2*a*J1*J2*sin22 + 2*b*J1*(J2**(3/2))*sin23
    dJ2_dt = -2*a*J1*J2*sin22 - 3*b*J1*(J2**(3/2))*sin23

    return  dp1_dt, dp2_dt, dJ1_dt, dJ2_dt


def euler(x_n, y_n, dHx, dHy, delta_t):
    '''
    Calcula o método de euler para as variáveis phi e J usando a derivada
    parcial correspondente

    Parameters
    ----------
    x_n : float
        variável integrada
    y_n : float
        variável não integrada
    dHx : float
        derivada parcial da hamiltoniana em função da variável integrada
    dHy : float
        derivada parcial da hamiltoniana em função da variável integrada
    delta_t : float
        passo de tempo para integração

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    y_(n+1) = y_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    -------
    '''
    return x_n + delta_t*dHx, y_n + delta_t*dHy

def newton(p1_n1, p1_ne, p2_n1, p2_ne, dt, J1, J2, a, b, e):
    '''
    Calcula o método de Newton para determinar phi^{n+1}

    Parameters
    ----------
    p1_n1 : float
        Chute para o método de newton.
    p1_ne : float
        Resultado interior da integração numérica.
    p2_n1 : float
        Chute para o método de newton.
    p2_ne : float
        Resultado interior da integração numérica.
    dt : float
        Passo temporal.
    J1 : float
        Variável de ação da integração numérica.
    J2 : float
        Variável de ação da integração numérica.
    a : float
        Parâmetro
    b : float
        Parâmetro
    e : float
        Erro requirido.

    Returns ph1^{n+1}, phi2^{n+2}
    -------
    '''

    while True: #intera indefinidamente

        p1_n = p1_n1
        p2_n = p2_n1

        #funções trignométricas
        cos22 = round(np.cos(2*p1_n - 2*p2_n),10)
        cos23 = round(np.cos(2*p1_n -3*p2_n),10)
        sin22 = round(np.sin(2*p1_n - 2*p2_n),10)
        sin23 = round(np.sin(2*p1_n -3*p2_n),10)

        #g1 e g2
        g1 = p1_n - p1_ne - dt * ( 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23)
        g2 = p2_n - p2_ne - dt * (1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23)

        if np.abs(g1) < e or np.abs(g2) < e: #verifica se está menor que o erro aceitável
            break

        B = [-g1, -g2] #matriz B

        #elementos da matriz A
        dg1_dp1 = 1 -dt * ((-2  * a*J2*sin22) - (2 * b*(J2**(3/2))*sin23))
        dg1_dp2 =  -dt * ((2 * a*J2*sin22) + (3 * b*(J2**(3/2))*sin23))
        dg2_dp1 = -dt * ((-2 * a*J1*sin22) - (3 *b*J1*(J2**(1/2))*sin23))
        dg2_dp2 = 1 -dt * ((2 * a*J1*sin22) + ((9/2) *b*J1*(J2**(1/2))*sin23))

        #matriz A
        A = [[dg1_dp1, dg1_dp2],[dg2_dp1, dg2_dp2]]

        #decomposição LU
        u11 = A[0][0]
        l21 = (A[1][0])/u11
        u12 = A[0][1]
        u22 = A[1][1] - l21*u12

        #L = [[1, 0], [l21, 1]] #matriz L

        #U = [[u11, u12], [0, u22]] #matriz U

        #solução do método de newton pelo método LU
        x1 = B[0]

        x2 = B[1] - l21*x1

        q2 = x2/u22

        q1 = (x1 - u12*q2)/u11

        #atualiza as variáveis
        p1_n1 = q1 + p1_n

        p2_n1 = q2 + p2_n


        del q1, q2, x1, x2, A, u11, l21, u12, u22
    #gc.collect()

    return p1_n1, p2_n1

def con_iniciais(p1, p2, J2, a, b, E = 0.08333):
    '''
    Calcula J1 por bhaskara a partir da fixação das outras variáveis da hamiloniana
    Parameters
    ----------
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    E : float, opcional
        Energia. O padrão é 0.08333.

    Returns p1, p2, J1, J2
    -------
    '''
    #J**2 - J1*(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2)) + E - J2**2

    #bhaskara
    a_bk = -1
    b_bk = float(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2))
    c_bk = J2**2 + J2 - E

    J1 = (-b_bk - ((b_bk*b_bk - 4*a_bk*c_bk)**(1/2)))/(2*a_bk)

    return p1, p2, J1, J2

def henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, u):
    '''
    Calcula o método de Henon para determinar a seção de Poicaré em termos das
    coordenadas de posição e momento

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    dp1 : float
        Derivada temporal de phi1
    dp2 : float
        Derivada temporal de phi2
    dJ1 : float
        Derivada temporal de J1
    dJ2 : float
        Derivada temporal de J2
    a : float
        Parâmetro
    b : float
        Parâmetro
    u : float
        Distância entre o ponto fixado e a seção de poicaré

    Returns q1, q2, m1, m2
    -------
    '''
    #método de henon
    p1 = p1
    p2 += u * (dp2/dp1)
    J1 += u * (dJ1/dp1)
    J2 += u * (dJ2/dp1)

    #cálculo da posição e momento
    q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)
    q2, m2 = ((2*J2)**(1/2))*np.cos(p2), -((2*J2)**(1/2))*np.sin(p2)
    return q1, q2, m1, m2

#parâmetros do EP
a = 0.02
b = 0.02
E = 0.18

#configuração da interação
dt = 0.05
t_max = 1500

#cores dos gráficos
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k','b', 'g', 'r', 'c', 'm', 'y', 'k']
iniciaisq = []
iniciaisp = []
#chutes iniciais para J2
for i in range(1, 102, 1):
  iniciaisq.append(10*i/350)
  if i%2 == 0:
    iniciaisp.append(np.pi)
  else:
    iniciaisp.append(0)
#iniciaisq = [0.025, 2*0.025, 0.05, 0.075, 0.1, 0.15, 0.2, 0.3, 0.4]#, 0.6, 0.8]# 0.15, 0.20]
#iniciaisq =  [0.3458, 0.3558]#, 0.375]# , 0.335]#, 0.375]# , 0.33, 0.4]# 0.405, 0.43, 0.45, 0.6, 0.8]# 0.15, 0.20]
#iniciaisq = [0.43, 0.45 ]#, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4] #, 0.90, 1.1, 0.5, 0.55, 0.7, 0.8]
#iniciaisp = [np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0]
iniciaisJ =[]
for i, element in enumerate(iniciaisq):
    if round(np.cos(iniciaisp[i]), 10) != 0.0:
        iniciaisJ.append((element/(round(np.cos(iniciaisp[i]), 10)))**2)
    else:
        iniciaisJ.append(0)
#controle do tempo de execução
start_time_ini = time.time()

#grandezas analisadas no EP
F2 = []
F1 = []
tempo = []
En =[]

#para cada chute inicial
for i in range(0, len(iniciaisJ), 1):
    #cria as listas para armazenar as variáveis de
    En.append([])
    t_henon = []
    lista_henon = []
    q2_henon = []
    m2_henon = []
    q1_list = []

    #checa se J1 é real ou não
    checa = False
    while checa == False:
        p1_n, p2_n, J1_n, J2_n = con_iniciais(3*np.pi/2, iniciaisp[i], iniciaisJ[i], a, b, E)
        print(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0])
        if 'nan' in str(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0]):
            sys.exit()
        #print(J1_n, J2_n, p1_n, p2_n)

        if type(J1_n) is not complex:
            checa = True

    #mostra quantos porcento foi execultado para cada chute inicial
    ax = None
    for t in range(0, round(t_max/dt), 1):
        #print(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0])
        nb_porcent = 100* t//(t_max/dt)
        porcent = str(nb_porcent)

        if nb_porcent % 10 == 0 and porcent != ax:
            print('% = ', 100*t//(t_max/dt), '%', end = ' ')
            ax = str(100* t//(t_max/dt))

    #uso um try para evitar erros
        try:

          p1, p2 = newton(3*np.pi/2, p1_n, iniciaisp[i], p2_n, dt, J1_n, J2_n, a, b, 10**(-9))

          dp1, dp2, dJ1, dJ2 = dH(p1, J1_n, p2, J2_n, a, b, dt)
          J1 = euler(p1, J1_n, dp1, dJ1, dt)[1]
          J2 = euler(p2, J2_n, dp2, dJ2, dt)[1]


          #En[i].append(H_WF(J1, J2, p1, p2, a, b)[0])

          #apenas para a primeira trajetória e para tempo menor que 100, gera os dados para F1 e F2
          '''if i == 0 and t < 100:
              tempo.append(t)
              F1.append(J1 + J2)
              F2.append(3*J1 + 2*J2)'''

          #converte os pontos para momento e posição
          q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)

          #se é a primeira interação eu calculo a posição anterior explicitamente
          if t == 0:
              q1_n =  ((2*J1_n)**(1/2))*np.cos(p1_n)

          #atualizado as variáveis para próxima interação
          #p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #print(q1, m1)
          #para checar se está calculando corretamente
          #q1_list.append(q1)

          #ALCIDES, ISSO AQUI É O MÉTODO QUE TEM QUE USAR, O DE BAIXO FOI EU METENDO O LOUCO PARA INTERAR MAIS VEZES
          if q1*q1_n < 0 and m1 > 0:  #Seção de Poincaré no plano p2 x q2
            dp1_n, dp2_n, dJ1_n, dJ2_n = dH(p1_n, J1_n, p2_n, J2_n, a, b, dt)
            m1_n = -((2*J1_n)**(1/2))*np.sin(p1_n)
            q1h, q2h, m1h, m2h = list(henon(p1_n, J1_n, p2_n, J2_n, dp1_n, dp2_n, dJ1_n, dJ2_n, a, b, dt, -(m1_n/(m1_n**2 + q1_n**2))*q1_n))#(m1/(m1**2 + q1**2))*q1))
            #print(q2h, m2h)
            plt.figure(1, figsize=(8, 6))
            plt.scatter(q2h, m2h, color=colors[i], s = 0.9)
            #T_henon.append(t)'''

          p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #atualizo q1
          q1_n = q1

          #(m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)
          #método aconchabrado
          '''if np.abs(q1) < 10**(-2) and m1 >= 0:
              q2h = ((2*J2)**(1/2))*np.cos(p2)
              m2h = -((2*J2)**(1/2))*np.sin(p2)
              #q1h, q2h, m1h, m2h = list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)))
              #print(q2h, m2h)
              plt.figure(1, figsize=(8, 6))
              plt.scatter(q2h, m2h, color=colors[i], s = 1.1)'''


        except:
            continue
    gc.collect()
    print('100%') #sinaliza que deu tudo certo

    #armazena o momento e posição para gerar a seção de poicaré
    '''for element in lista_henon:
      q2_henon.append(element[1])
      m2_henon.append(element[3])'''

    #plota a seção de poicaré


    #abaixo é para gerar gráficos da energia e verificar se está sendo uma constante de movimento
    '''plt.scatter(tempo, En[i], color=colors[i], s = 0.2)
    plt.ylim(0.16, 0.19)'''

#tempo de execução
end_time_ini = time.time()
timefinal = str((end_time_ini - start_time_ini)//60) + ' minutos e ' + str(round((end_time_ini - start_time_ini)%60,2)) + ' segundos'
print("Essa operação levou {}".format(timefinal))

#parâmetros dos gráficos
plt.title('Seção de Poincaré para E = {0}'.format(E))
plt.xlabel('$q_2$')
plt.ylabel('$p_2$')
plt.grid()
plt.show()

#abaixo cria os gráficos de F1 e F2
#MAS ALGO ESTÁ ERRADO, QUANDO VC USA max(F1) e min(F1) DA PRA VER QUE É UMA CONSTANTE
#DE MOVIMENTO, MAS NO GRÁFICO PARECE QUE NÃO, NÃO ENTENDI O QUE ACONTECEU E NÃO TIVE TEMPO '''acho que agora foi'''
#DE VERIFICAR PARA ARRUMAR
'''
plt.figure(2, figsize=(8, 6))
plt.scatter(tempo, F1, color=colors[i], s = 0.2)
plt.ylim(min(F1)+ 10**(-6), max(F1)- 10**(-6))
plt.xlabel('$t$')
plt.ylabel('$F1$')


plt.figure(3, figsize=(8, 6))
plt.scatter(tempo, F2, color=colors[i], s = 0.2)
plt.ylim( min(F2), max(F2))
plt.xlabel('$t$')
plt.ylabel('$F2$')
plt.show()'''
'''
for j, element in enumerate(En):
    plt.figure(j + 2, figsize=(8, 6))
    plt.scatter(tempo, element, color=colors[j], s = 0.2)
    plt.xlabel('$t$')
    plt.ylabel('$E$')
    plt.grid()
    plt.show()'''

# -*- coding: utf-8 -*-
"""
Created on Sat Oct 28 17:02:16 2023

@author: talgu
"""

# -*- coding: utf-8 -*-
"""
Created on Fri Oct 27 14:10:59 2023

@author: Gustavo
"""
import numpy as np
import matplotlib.pyplot as plt
import random
import time
import cProfile
import sys
import gc


def H_WF(J1, J2, p1, p2, a, b):
    '''
    Calcula a hamiltoniana de Walker-Ford a partir das variáveis de ângulo e
    ação

    Parameters
    ----------
    J1 : float
        Ação
    J2 : float
        Ação
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    a : float
        Parâmetro
    b : float
        Parâmetro

    Returns
    -------
    H : float
        Hamiltoniana de Walker-Ford
    H_0 : float
        Hamiltoniana não perturbada
    H_1 : float
        Perturbação

    '''

    H_0 = J1 + J2 - J1**2 - 3*J1*J2 + J2**2
    H_1 = a* J1 *J2 * np.cos(2*p1 - 2*p2) + b* J1 * (J2**(3/2))*np.cos(2*p1 - 3*p2)
    H = H_0 + H_1

    return H, H_0, H_1

def dH(p1, J1, p2, J2, a, b, dt):
    '''
    Função que calcula a derivada parcial da hamiltoniana

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    dt : float
        Passo temporal

    Returns : dp1/dt, dp2/dt, dJ1/dt, dJ2/dt
    -------
    '''

    #funções trigonométricas
    cos22 = np.cos(2*p1 - 2*p2)
    cos23 = np.cos(2*p1 -3*p2)
    sin22 = np.sin(2*p1 - 2*p2)
    sin23 = np.sin(2*p1 -3*p2)

    #derivadas temporais
    dp1_dt = 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23
    dp2_dt = 1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23

    dJ1_dt = +2*a*J1*J2*sin22 + 2*b*J1*(J2**(3/2))*sin23
    dJ2_dt = -2*a*J1*J2*sin22 - 3*b*J1*(J2**(3/2))*sin23

    return  dp1_dt, dp2_dt, dJ1_dt, dJ2_dt


def euler(x_n, y_n, dHx, dHy, delta_t):
    '''
    Calcula o método de euler para as variáveis phi e J usando a derivada
    parcial correspondente

    Parameters
    ----------
    x_n : float
        variável integrada
    y_n : float
        variável não integrada
    dHx : float
        derivada parcial da hamiltoniana em função da variável integrada
    dHy : float
        derivada parcial da hamiltoniana em função da variável integrada
    delta_t : float
        passo de tempo para integração

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    y_(n+1) = y_(n) + delta_t * dH_(x_(n + 1), y_(n)),
    -------
    '''
    return x_n + delta_t*dHx, y_n + delta_t*dHy

def newton(p1_n1, p1_ne, p2_n1, p2_ne, dt, J1, J2, a, b, e):
    '''
    Calcula o método de Newton para determinar phi^{n+1}

    Parameters
    ----------
    p1_n1 : float
        Chute para o método de newton.
    p1_ne : float
        Resultado interior da integração numérica.
    p2_n1 : float
        Chute para o método de newton.
    p2_ne : float
        Resultado interior da integração numérica.
    dt : float
        Passo temporal.
    J1 : float
        Variável de ação da integração numérica.
    J2 : float
        Variável de ação da integração numérica.
    a : float
        Parâmetro
    b : float
        Parâmetro
    e : float
        Erro requirido.

    Returns ph1^{n+1}, phi2^{n+2}
    -------
    '''

    while True: #intera indefinidamente

        p1_n = p1_n1
        p2_n = p2_n1

        #funções trignométricas
        cos22 = round(np.cos(2*p1_n - 2*p2_n),10)
        cos23 = round(np.cos(2*p1_n -3*p2_n),10)
        sin22 = round(np.sin(2*p1_n - 2*p2_n),10)
        sin23 = round(np.sin(2*p1_n -3*p2_n),10)

        #g1 e g2
        g1 = p1_n - p1_ne - dt * ( 1 - 2*J1 - 3*J2 + a*J2*cos22 + b*(J2**(3/2))*cos23)
        g2 = p2_n - p2_ne - dt * (1 - 3*J1 + 2*J2 + a*J1*cos22 + (3/2)*b*J1*(J2**(1/2))*cos23)

        if np.abs(g1) < e or np.abs(g2) < e: #verifica se está menor que o erro aceitável
            break

        B = [-g1, -g2] #matriz B

        #elementos da matriz A
        dg1_dp1 = 1 -dt * ((-2  * a*J2*sin22) - (2 * b*(J2**(3/2))*sin23))
        dg1_dp2 =  -dt * ((2 * a*J2*sin22) + (3 * b*(J2**(3/2))*sin23))
        dg2_dp1 = -dt * ((-2 * a*J1*sin22) - (3 *b*J1*(J2**(1/2))*sin23))
        dg2_dp2 = 1 -dt * ((2 * a*J1*sin22) + ((9/2) *b*J1*(J2**(1/2))*sin23))

        #matriz A
        A = [[dg1_dp1, dg1_dp2],[dg2_dp1, dg2_dp2]]

        #decomposição LU
        u11 = A[0][0]
        l21 = (A[1][0])/u11
        u12 = A[0][1]
        u22 = A[1][1] - l21*u12

        #L = [[1, 0], [l21, 1]] #matriz L

        #U = [[u11, u12], [0, u22]] #matriz U

        #solução do método de newton pelo método LU
        x1 = B[0]

        x2 = B[1] - l21*x1

        q2 = x2/u22

        q1 = (x1 - u12*q2)/u11

        #atualiza as variáveis
        p1_n1 = q1 + p1_n

        p2_n1 = q2 + p2_n


        del q1, q2, x1, x2, A, u11, l21, u12, u22
    #gc.collect()

    return p1_n1, p2_n1

def con_iniciais(p1, p2, J2, a, b, E = 0.08333):
    '''
    Calcula J1 por bhaskara a partir da fixação das outras variáveis da hamiloniana
    Parameters
    ----------
    p1 : float
        Ãngulo
    p2 : float
        Ângulo
    J2 : float
        Ação
    a : float
        Parâmetro
    b : float
        Parâmetro
    E : float, opcional
        Energia. O padrão é 0.08333.

    Returns p1, p2, J1, J2
    -------
    '''
    #J**2 - J1*(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2)) + E - J2**2

    #bhaskara
    a_bk = -1
    b_bk = float(1 - 3*J2 + a*J2 * np.cos(2*p1 - 2*p2) + b * (J2**(3/2))*np.cos(2*p1 - 3*p2))
    c_bk = J2**2 + J2 - E

    J1 = (-b_bk - ((b_bk*b_bk - 4*a_bk*c_bk)**(1/2)))/(2*a_bk)

    return p1, p2, J1, J2

def henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, u):
    '''
    Calcula o método de Henon para determinar a seção de Poicaré em termos das
    coordenadas de posição e momento

    Parameters
    ----------
    p1 : float
        Ãngulo
    J1 : float
        Ação
    p2 : float
        Ângulo
    J2 : float
        Ação
    dp1 : float
        Derivada temporal de phi1
    dp2 : float
        Derivada temporal de phi2
    dJ1 : float
        Derivada temporal de J1
    dJ2 : float
        Derivada temporal de J2
    a : float
        Parâmetro
    b : float
        Parâmetro
    u : float
        Distância entre o ponto fixado e a seção de poicaré

    Returns q1, q2, m1, m2
    -------
    '''
    #método de henon
    p1 = p1
    p2 += u * (dp2/dp1)
    J1 += u * (dJ1/dp1)
    J2 += u * (dJ2/dp1)

    #cálculo da posição e momento
    q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)
    q2, m2 = ((2*J2)**(1/2))*np.cos(p2), -((2*J2)**(1/2))*np.sin(p2)
    return q1, q2, m1, m2

#parâmetros do EP
a = 0.02
b = 0.02
E = 0.18

#configuração da interação
dt = 0.1
t_max = 5000

#cores dos gráficos
colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k','b', 'g', 'r', 'c', 'm', 'y', 'k']

#chutes iniciais para J2
iniciaisq = [0.1, 0.2, 0.3555, 0.343, 0.3, 0.405, 0.53, 0.7]#, 0.6, 0.8]# 0.15, 0.20]
#iniciaisq =  [0.3555, 0.343]#, 0.3558, 0.35, 0.38, 0.45]# , 0.335]#, 0.375]# , 0.33, 0.4]# 0.405, 0.43, 0.45, 0.6, 0.8]# 0.15, 0.20]
#iniciaisq = [0.43, 0.45 ]#, 0.35, 0.36, 0.37, 0.38, 0.39, 0.4] #, 0.90, 1.1, 0.5, 0.55, 0.7, 0.8]
iniciaisp = [np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0, np.pi, 0]
iniciaisJ =[]
for i, element in enumerate(iniciaisq):
    if round(np.cos(iniciaisp[i]), 10) != 0.0:
        iniciaisJ.append((element/(round(np.cos(iniciaisp[i]), 10)))**2)
    else:
        iniciaisJ.append(0)
#controle do tempo de execução
start_time_ini = time.time()

#grandezas analisadas no EP
F2 = []
F1 = []
tempo = []
En =[]

#para cada chute inicial
for i in range(0, len(iniciaisJ), 1):
    #cria as listas para armazenar as variáveis de
    En.append([])
    t_henon = []
    lista_henon = []
    q2_henon = []
    m2_henon = []
    q1_list = []

    #checa se J1 é real ou não
    checa = False
    while checa == False:
        p1_n, p2_n, J1_n, J2_n = con_iniciais(3*np.pi/2, iniciaisp[i], iniciaisJ[i], a, b, E)
        print(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0])
        if 'nan' in str(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0]):
            sys.exit()
        #print(J1_n, J2_n, p1_n, p2_n)

        if type(J1_n) is not complex:
            checa = True

    #mostra quantos porcento foi execultado para cada chute inicial
    ax = None
    for t in range(0, round(t_max/dt), 1):
        #print(H_WF(J1_n, J2_n, p1_n, p2_n, a, b)[0])
        nb_porcent = 100* t//(t_max/dt)
        porcent = str(nb_porcent)

        if nb_porcent % 10 == 0 and porcent != ax:
            print('% = ', 100*t//(t_max/dt), '%', end = ' ')
            ax = str(100* t//(t_max/dt))

    #uso um try para evitar erros
        try:

          p1, p2 = newton(3*np.pi/2, p1_n, iniciaisp[i], p2_n, dt, J1_n, J2_n, a, b, 10**(-6))

          dp1, dp2, dJ1, dJ2 = dH(p1, J1_n, p2, J2_n, a, b, dt)
          J1 = euler(p1, J1_n, dp1, dJ1, dt)[1]
          J2 = euler(p2, J2_n, dp2, dJ2, dt)[1]


          #En[i].append(H_WF(J1, J2, p1, p2, a, b)[0])

          #apenas para a primeira trajetória e para tempo menor que 100, gera os dados para F1 e F2
          '''if i == 0 and t < 100:
              tempo.append(t)
              F1.append(J1 + J2)
              F2.append(3*J1 + 2*J2)'''

          #converte os pontos para momento e posição
          q1, m1 = ((2*J1)**(1/2))*np.cos(p1), -((2*J1)**(1/2))*np.sin(p1)

          #se é a primeira interação eu calculo a posição anterior explicitamente
          if t == 0:
              q1_n =  ((2*J1_n)**(1/2))*np.cos(p1_n)

          #atualizado as variáveis para próxima interação
          #p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #print(q1, m1)
          #para checar se está calculando corretamente
          #q1_list.append(q1)

          #ALCIDES, ISSO AQUI É O MÉTODO QUE TEM QUE USAR, O DE BAIXO FOI EU METENDO O LOUCO PARA INTERAR MAIS VEZES
          if q1*q1_n < 0 and m1 > 0:  #Seção de Poincaré no plano p2 x q2
            dp1_n, dp2_n, dJ1_n, dJ2_n = dH(p1_n, J1_n, p2_n, J2_n, a, b, dt)
            m1_n = -((2*J1_n)**(1/2))*np.sin(p1_n)
            q1h, q2h, m1h, m2h = list(henon(p1_n, J1_n, p2_n, J2_n, dp1_n, dp2_n, dJ1_n, dJ2_n, a, b, dt, -(m1_n/(m1_n**2 + q1_n**2))*q1_n))#(m1/(m1**2 + q1**2))*q1))
            #print(q2h, m2h)
            plt.figure(1, figsize=(8, 6))
            plt.scatter(q2h, m2h, color=colors[i], s = 0.9)
            #T_henon.append(t)'''

          p1_n, p2_n, J1_n, J2_n = p1, p2, J1, J2

          #atualizo q1
          q1_n = q1

          #(m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)
          #método aconchabrado
          '''if np.abs(q1) < 10**(-2) and m1 >= 0:
              q2h = ((2*J2)**(1/2))*np.cos(p2)
              m2h = -((2*J2)**(1/2))*np.sin(p2)
              #q1h, q2h, m1h, m2h = list(henon(p1, J1, p2, J2, dp1, dp2, dJ1, dJ2, a, b, dt, (m1/((q1**2)*(1 +(p1**2)/(q1**2))))*(-q1)))
              #print(q2h, m2h)
              plt.figure(1, figsize=(8, 6))
              plt.scatter(q2h, m2h, color=colors[i], s = 1.1)'''


        except:
            continue
    gc.collect()
    print('100%') #sinaliza que deu tudo certo

    #armazena o momento e posição para gerar a seção de poicaré
    '''for element in lista_henon:
      q2_henon.append(element[1])
      m2_henon.append(element[3])'''

    #plota a seção de poicaré


    #abaixo é para gerar gráficos da energia e verificar se está sendo uma constante de movimento
    '''plt.scatter(tempo, En[i], color=colors[i], s = 0.2)
    plt.ylim(0.16, 0.19)'''

#tempo de execução
end_time_ini = time.time()
timefinal = str((end_time_ini - start_time_ini)//60) + ' minutos e ' + str(round((end_time_ini - start_time_ini)%60,2)) + ' segundos'
print("Essa operação levou {}".format(timefinal))

#parâmetros dos gráficos
plt.title('Seção de Poincaré para E = {0}'.format(E))
plt.xlabel('$q_2$')
plt.ylabel('$p_2$')
plt.grid()
plt.show()

#abaixo cria os gráficos de F1 e F2
#MAS ALGO ESTÁ ERRADO, QUANDO VC USA max(F1) e min(F1) DA PRA VER QUE É UMA CONSTANTE
#DE MOVIMENTO, MAS NO GRÁFICO PARECE QUE NÃO, NÃO ENTENDI O QUE ACONTECEU E NÃO TIVE TEMPO '''acho que agora foi'''
#DE VERIFICAR PARA ARRUMAR
'''
plt.figure(2, figsize=(8, 6))
plt.scatter(tempo, F1, color=colors[i], s = 0.2)
plt.ylim(min(F1)+ 10**(-6), max(F1)- 10**(-6))
plt.xlabel('$t$')
plt.ylabel('$F1$')


plt.figure(3, figsize=(8, 6))
plt.scatter(tempo, F2, color=colors[i], s = 0.2)
plt.ylim( min(F2), max(F2))
plt.xlabel('$t$')
plt.ylabel('$F2$')
plt.show()'''
'''
for j, element in enumerate(En):
    plt.figure(j + 2, figsize=(8, 6))
    plt.scatter(tempo, element, color=colors[j], s = 0.2)
    plt.xlabel('$t$')
    plt.ylabel('$E$')
    plt.grid()
    plt.show()'''