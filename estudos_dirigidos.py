# -*- coding: utf-8 -*-
"""Estudos Dirigidos

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1klD5HbWaWhfcxDrRzSJ2FfjH89Tt4zzT

Estudo Dirigido 1 - Mecânica Clássica

Exercício 1 - Pêndulo simples
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import FuncFormatter

def H(p, q):
    '''
    Função que calcula a hamiltoniana de um pêndulo

    Parameters
    ----------
    p : float
        Momento conjugado da partícula.
    q : float
        variável canônica.

    Returns : (p)^2/2 - cos(q)
    -------
    '''
    return (p**2)/2 - np.cos(q)

def dH_p(q, p):
    '''
    Função que calcula a derivada parcial da hamiltoniana de um pêndulo em
    função de p

    Parameters
    ----------
    p : float
        Momento conjugado da partícula.
    q : float
        variável canônica.

    Returns : p
    -------
    '''
    return p

def dH_q(q, p):
    '''
    Função que calcula a derivada parcial da hamiltoniana de um pêndulo em
    função de q

    Parameters
    ----------
    p : float
        Momento conjugado da partícula.
    q : float
        variável canônica.

    Returns : sen(q)
    -------
    '''
    return np.sin(q)

def euler(x_n, y_n, dH, delta_t):
    '''
    Calcula o método de euler para as variáveis q e p usando a derivada
    parcial correspondente

    Parameters
    ----------
    x_n : float
        variável integrada
    y_n : float
        variável não integrada
    dH : float
        derivada parcial da hamiltoniana em função da variável integrada
    delta_t : float
        passo de tempo para integração

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n), y_(n)) com x = p ou q e
    y = q ou p
    -------
    '''
    return x_n + delta_t*dH

def ed_plot(x, y, delta_t, colors, n = 1, col = 1, tx = "x", ty = "y",
            title = None, geral_title = None):
    '''
    Cria os gráficos

    Parameters
    ----------
    x : list
        variável do eixo horizontal

    y : list
        variável do eixo vertical

    delta_t : float
        passo da integração numérica

    colors : float
        cor da linha

    n : int
        número da figura quando se tem multiplos gráficos

    col : int
        posição do gráfico

    tx : str
        título do eixo horizontal

    ty : str
        título do eixo vertical

    title : str
        título do gráfico

    geral_title : str
        título da figura
    -------
    '''

    plt.figure(n, figsize=(12, 6)) # posiciona o gráfico na figura "n"
    plt.subplot(1, 2, col) # e na coluna col

    plt.subplots_adjust(wspace=0.3) #distância entre os gráficos de uma mesma figura

    if title is not None: # se há título, o acrescenta no gráfico
        plt.title(title, fontsize = 10)

    if geral_title is not None: # se há título, o acrescenta na figura
        plt.suptitle(geral_title, fontsize = 16)

    plt.plot(x, y, label= "$\Delta$t = " + str(delta_t), color=colors) #legenda de cada curva

    plt.xlabel(tx) #legenda dos eixos
    plt.ylabel(ty)

    #verifica se o valor máximo e mínimo de y é maior do que um inteiro
    if (np.amax(list(plt.yticks()[0])) - np.amin(list(plt.yticks()[0]))) > 1:
        formatter = FuncFormatter(lambda y, _: '{:.1f}'.format(y)) # Formatar os ticks do eixo y para terem apenas uma casa decimal
    else: #se não
        formatter = FuncFormatter(lambda y, _: '{:.2f}'.format(y))# Formatar os ticks do eixo y para terem apenas duas casa decimais

    plt.gca().yaxis.set_major_formatter(formatter) #aplica a formatação


    plt.legend(loc='upper left') #adiciona a legenda


def ed_pendulo(q_0 = 2*3.14, p_0 = 0.5, geral_title = None, e = True):
  '''
    Cria os gráficos

    Parameters
    ----------
    q_0 : float
        chute inicial para variável canônica

    p_0 : float
        chute inicial para o momento conjugado

    geral_title : str
        título da figura

    e : bool
        determina se calculará pelo método de Euler
    -------
    '''

  Dt = [10**(-1), 10**(-2), 10**(-3)] #passo temporal

  for i, delta_t in reversed(list(enumerate(Dt))): #gera as curvas para cada passo temporal

      colors = ['g', 'r', 'b'] #cores das linhas

      #armazena o resultado das interações

      q = [] #euler
      p = []
      E = []

      ps = [] #simplético
      qs = []
      Es = []

      t = [] #tempo

      tn = 0 #tempo em cada interação

      while tn <= 10:
          if tn == 0: #chutes iniciais
              q_n1 = q_0 #euler
              q_s1 = q_0

              p_n1 = p_0 #simplético
              p_s1 = p_0

          else:
              q_n1 = euler(q_n, p_n, dH_p(q_n, p_n), delta_t) #método de euler
              p_n1 = euler(p_n, q_n, dH_q(q_n, p_n), (-1)*delta_t)

              q_s1 = euler(q_s, p_s, dH_p(q_s1, p_s), delta_t)
              p_s1 = euler(p_s, q_s, dH_q(q_s1, p_s), (-1)*delta_t) #simplético

          #registra os valores da interação para usar na seguinte
          q_n = q_n1 #euler
          p_n = p_n1

          q_s = q_s1 #simplético
          p_s = p_s1

          #armazena o resultados a cada interação para gerar as cruvas
          q.append(q_n1)
          p.append(p_n1)
          ps.append(p_s1)
          qs.append(q_s1)
          E.append(H(p_n1, q_n1))
          Es.append(H(p_s1, q_n1))
          t.append(tn)

          tn += delta_t #atualiza o loop

      #verifica se apresenta o resultado do método de euler
      if e == True:
        #constroi os gráficos
        ed_plot(q, p, delta_t, colors[i], n = 1, tx = 'q(t)', ty = 'p(t)', title = "Espaço de fase", geral_title = geral_title)
        ed_plot(t, p, delta_t, colors[i], n = 2, tx = 't', ty = 'p(t)', title = 'Momento em função do tempo')
        ed_plot(t, q, delta_t, colors[i], n = 3, tx = 't', ty = 'q(t)', title = "Coordenada em função do tempo")
        ed_plot(t, E, delta_t, colors[i], n = 4, tx = 't', ty = 'E(t)', title = "Energia em função do tempo")
        coluna = 2
      else:
        coluna = 1 #se não, realoca os gráficos do simplético

      ed_plot(qs, ps, delta_t, colors[i], n = 1, col = coluna, tx = 'q(t)', ty = 'p(t)', title = "Espaço de fase (simplético)", geral_title = geral_title)
      ed_plot(t, ps, delta_t, colors[i], n = 2, col = coluna, tx = 't', ty = 'p(t)', title = 'Momento em função do tempo (simplético)')
      ed_plot(t, qs, delta_t, colors[i], n = 3, col = coluna, tx = 't', ty = 'q(t)', title = "Coordenada em função do tempo (simplético)")
      ed_plot(t, Es, delta_t, colors[i], n = 4, col = coluna, tx = 't', ty = 'E(t)', title = "Energia em função do tempo (simplético)")

  # Exibe o gráfico
  plt.show()

#resultados
ed_pendulo(geral_title = "Libração")
ed_pendulo(3.14, 1, geral_title = "Rotação")

"""Exercício 2 - Hénon-Heiles

Seção de Poincaré
"""

import numpy as np
import matplotlib.pyplot as plt
import random


# Condições iniciais
def con_iniciais(q1, q2, p1, E = 0.08333):
    #garante que, independente do chute inicial, sempre tenhamos a energia predeterminada
    p2 = (2*E + 2*(q2**(3))/3 - 2*(q1**(2))*q2 - (p1**(2) + q1**(2) + q2**(2)))**(1/2)
    return q1, q2, p1, p2

# Hamiltoniana de Hénon-Heiles
def H(q1, q2, p1, p2):
    return 0.5*(p1**2 + p2**2 + q1**2 + q2**2) + (q1**2)*q2 - (q2**3)/3

# Método de Euler simplético
def euler_simp(q1, q2, p1, p2, h):
    q1 += h * p1
    q2 += h * p2
    p1 -= h * (q1 + (2 * q1 * q2))
    p2 -= h * (q2+ (q1**(2)) - (q2**(2)))
    return q1, q2, p1, p2


# Algoritmo de Hénon
def henon(q1, q2, p1, p2, u):
    q1 += q1
    q2 += u * p2/p1
    p1 -= u * (q1 + 2*q1*q2)/p1
    p2 -= u * (q2 + q1**2 - q2**2)/p1
    return q1, q2, p1, p2



#E = 0.166667 #0.125#0.08333
E = 0.166667 #energia

q2_henon = [] #lista para armazenar os parâmetros para construir o espaço de fase
p2_henon = []

for i in range(0, 20): #quantidade de trajetórias

    checa = False
    while checa == False:
        q1r, q2r, p1r  = random.uniform(0, 0.5), random.uniform(-0.5, 0.9), random.uniform(0, 0.1) #chutes aleatórios

        q1, q2, p1, p2 = con_iniciais(q1r, q2r, p1r, E)

        if type(p2) is not complex: #verifica se p2 é real
            checa = True

    # Parâmetros do método
    h = 0.1  # passo de tempo
    t_max = 10000  # tempo máximo de simulação



    q1_a, q2_a, p1_a, p2_a = None, None, None, None #valores anteriores a interação atual
    lista_henon = [] #armazena os resultados do algoritmo de henon

    # Loop principal
    for t in np.arange(0, t_max, h):
      try:
        q1_a, q2_a, p1_a, p2_a = q1, q2, p1, p2
        q1, q2, p1, p2 = euler_simp(q1, q2, p1, p2, h) #calcula euler simple´tico

        if p1 > 2 or q1 > 2 or p2 > 1 or q2 > 1: #caso o valor exceda esses limites ele não continua a interação (para não divergir)
            continue

        if q1*q1_a < 0 and p1 >= 0:  #Seção de Poincaré no plano p2 x q2
          lista_henon.append(list(henon(q1, q2, p1, p2, 0 - q1))) #determina os componentes da seção de poincaré

      except:
          continue


    for element in lista_henon: #retira as componentes de interesse
      q2_henon.append(element[1])
      p2_henon.append(element[3])

#cria o gráfico
plt.figure(figsize=(8, 6))
plt.scatter(q2_henon, p2_henon, color='b', s = 0.2)
plt.title('Seção de Poincaré para E = {}'.format(E))
plt.xlabel('$q_2$')
plt.ylabel('$p_2$')
plt.legend()
plt.grid()
plt.show()

"""Função do tempo periódica"""

import numpy as np
import matplotlib.pyplot as plt

from matplotlib.ticker import FuncFormatter

# Condições iniciais
def con_iniciais(q1, q2, p2, E = 0.08333):
    #garante que, independente do chute inicial, sempre tenhamos a energia predeterminada
    p1 = (2*E + 2*(q2**(3))/3 - 2*(q1**(2))*q2 - (p2**(2) + q1**(2) + q2**(2)))**(1/2)
    return q1, q2, p1, p2

# Hamiltoniana de Hénon-Heiles
def H(q1, q2, p1, p2):
    return 0.5*(p1**2 + p2**2 + q1**2 + q2**2) + (q1**2)*q2 - (q2**3)/3

# Método de Euler simplético
def euler_simp(q1, q2, p1, p2, h):
    q1 += h * p1
    q2 += h * p2
    p1 -= h * (q1 + (2 * q1 * q2))
    p2 -= h * (q2+ (q1**(2)) - (q2**(2)))
    return q1, q2, p1, p2


# Algoritmo de Hénon
def henon(q1, q2, p1, p2, u):
    q1 += q1
    q2 += u * p2/p1
    p1 -= u * (q1 + 2*q1*q2)/p1
    p2 -= u * (q2 + q1**2 - q2**2)/p1
    return q1, q2, p1, p2

def ed_plot(x, y, delta_t, colors, n = 1, col = 1, tx = "x", ty = "y",
            title = None, geral_title = None):
    '''
    Cria os gráficos

    Parameters
    ----------
    x : list
        variável do eixo horizontal

    y : list
        variável do eixo vertical

    delta_t : float
        passo da integração numérica

    colors : float
        cor da linha

    n : int
        número da figura quando se tem multiplos gráficos

    col : int
        posição do gráfico

    tx : str
        título do eixo horizontal

    ty : str
        título do eixo vertical

    title : str
        título do gráfico

    geral_title : str
        título da figura

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n), y_(n)) com x = p ou q e
    y = q ou p
    -------
    '''

    plt.figure(n, figsize=(12, 6)) # posiciona o gráfico na figura "n"
    plt.subplot(1, 2, col) # e na coluna col

    plt.subplots_adjust(wspace=0.3) #distância entre os gráficos de uma mesma figura

    if title is not None: # se há título, o acrescenta no gráfico
        plt.title(title, fontsize = 10)

    if geral_title is not None: # se há título, o acrescenta na figura
        plt.suptitle(geral_title, fontsize = 16)

    plt.plot(x, y, label= str(delta_t), color=colors) #legenda de cada curva

    plt.xlabel(tx) #legenda dos eixos
    plt.ylabel(ty)

    #verifica se o valor máximo e mínimo de y é maior do que um inteiro
    if (np.amax(list(plt.yticks()[0])) - np.amin(list(plt.yticks()[0]))) > 1:
        formatter = FuncFormatter(lambda y, _: '{:.1f}'.format(y)) # Formatar os ticks do eixo y para terem apenas uma casa decimal
    else: #se não
        formatter = FuncFormatter(lambda y, _: '{:.2f}'.format(y))# Formatar os ticks do eixo y para terem apenas duas casa decimais

    plt.gca().yaxis.set_major_formatter(formatter) #aplica a formatação


    plt.legend(loc='upper left') #adiciona a legenda

E = 0.125


# Gere um número aleatório entre 0 e 0.
checa = False
while checa == False:
    q1r, q2r, p2r  = 0, 0.3, 0
    q1, q2, p1, p2 = con_iniciais(q1r, q2r, p2r, E)
    if type(p2) is not complex:
        checa = True

# Parâmetros
h = 0.1  # passo de tempo
t_max = 200  # tempo máximo de simulação


q1_a, q2_a, p1_a, p2_a = None, None, None, None #valores a interação atual

#lista para armazenar os parâmetros para construir o espaço de fase
lista_henon = []
t_henon = []
q2_henon = []
p2_henon = []
q1_henon = []
p1_henon = []

# Loop principal
for t in np.arange(0, t_max, h):
  try:
    q1_a, q2_a, p1_a, p2_a = q1, q2, p1, p2
    q1, q2, p1, p2 = euler_simp(q1, q2, p1, p2, h) #calcula euler simple´tico

    if p1 > 2 or q1 > 2 or p2 > 1 or q2 > 1: #caso o valor exceda esses limites ele não continua a interação (para não divergir)
        continue

    if q1*q1_a < 0 and p1 >= 0:  #Seção de Poincaré no plano p2 x q2
      lista_henon.append(list(henon(q1, q2, p1, p2, 0 - q1))) #determina os componentes da seção de poincaré
      t_henon.append(t) #tempo em que ocorreu a intersecção

  except:
      continue


for element in lista_henon: #retira as componentes de interesse
  q2_henon.append(element[1])
  p2_henon.append(element[3])
  q1_henon.append(element[0])
  p1_henon.append(element[2])

#cria os gráfico
method = 'periódico'
ed_plot(t_henon, q2_henon , 'E = {}'.format(E) ,'r', 1, tx = 't',
        ty = '$q_2(t)$', title = "{0} em função de t em regime {1}".format('$q_2(t)$', method))
ed_plot(t_henon, q1_henon , 'E = {}'.format(E) , 'r', 2,  tx = 't',
        ty = '$q_1(t)$', title = "{0} em função de t em regime {1}".format('$q_1(t)$', method))
ed_plot(t_henon, p2_henon , 'E = {}'.format(E) , 'r', 3,  tx = 't',
        ty = '$p_2(t)$', title = "{0} em função de t em regime {1}".format('$p_2(t)$', method))
ed_plot(t_henon, p1_henon , 'E = {}'.format(E) , 'r', 4,  tx = 't',
        ty = '$p_1(t)$', title = "{0} em função de t em regime {1}" .format('$p_1(t)$', method))

"""Função do tempo caótica"""

import numpy as np
import matplotlib.pyplot as plt

from matplotlib.ticker import FuncFormatter

# Condições iniciais
def con_iniciais(q1, q2, p2, E = 0.08333):
    #garante que, independente do chute inicial, sempre tenhamos a energia predeterminada
    p1 = (2*E + 2*(q2**(3))/3 - 2*(q1**(2))*q2 - (p2**(2) + q1**(2) + q2**(2)))**(1/2)
    return q1, q2, p1, p2

# Hamiltoniana de Hénon-Heiles
def H(q1, q2, p1, p2):
    return 0.5*(p1**2 + p2**2 + q1**2 + q2**2) + (q1**2)*q2 - (q2**3)/3

# Método de Euler simplético
def euler_simp(q1, q2, p1, p2, h):
    q1 += h * p1
    q2 += h * p2
    p1 -= h * (q1 + (2 * q1 * q2))
    p2 -= h * (q2+ (q1**(2)) - (q2**(2)))
    return q1, q2, p1, p2


# Algoritmo de Hénon
def henon(q1, q2, p1, p2, u):
    q1 += q1
    q2 += u * p2/p1
    p1 -= u * (q1 + 2*q1*q2)/p1
    p2 -= u * (q2 + q1**2 - q2**2)/p1
    return q1, q2, p1, p2

def ed_plot(x, y, delta_t, colors, n = 1, col = 1, tx = "x", ty = "y",
            title = None, geral_title = None):
    '''
    Cria os gráficos

    Parameters
    ----------
    x : list
        variável do eixo horizontal

    y : list
        variável do eixo vertical

    delta_t : float
        passo da integração numérica

    colors : float
        cor da linha

    n : int
        número da figura quando se tem multiplos gráficos

    col : int
        posição do gráfico

    tx : str
        título do eixo horizontal

    ty : str
        título do eixo vertical

    title : str
        título do gráfico

    geral_title : str
        título da figura

    Returns: x_(n+1) = x_(n) + delta_t * dH_(x_(n), y_(n)) com x = p ou q e
    y = q ou p
    -------
    '''

    plt.figure(n, figsize=(12, 6)) # posiciona o gráfico na figura "n"
    plt.subplot(1, 2, col) # e na coluna col

    plt.subplots_adjust(wspace=0.3) #distância entre os gráficos de uma mesma figura

    if title is not None: # se há título, o acrescenta no gráfico
        plt.title(title, fontsize = 10)

    if geral_title is not None: # se há título, o acrescenta na figura
        plt.suptitle(geral_title, fontsize = 16)

    plt.plot(x, y, label= str(delta_t), color=colors) #legenda de cada curva

    plt.xlabel(tx) #legenda dos eixos
    plt.ylabel(ty)

    #verifica se o valor máximo e mínimo de y é maior do que um inteiro
    if (np.amax(list(plt.yticks()[0])) - np.amin(list(plt.yticks()[0]))) > 1:
        formatter = FuncFormatter(lambda y, _: '{:.1f}'.format(y)) # Formatar os ticks do eixo y para terem apenas uma casa decimal
    else: #se não
        formatter = FuncFormatter(lambda y, _: '{:.2f}'.format(y))# Formatar os ticks do eixo y para terem apenas duas casa decimais

    plt.gca().yaxis.set_major_formatter(formatter) #aplica a formatação


    plt.legend(loc='upper left') #adiciona a legenda

E = 0.125


# Gere um número aleatório entre 0 e 0.
checa = False
while checa == False:
    q1r, q2r, p2r  = 0, -0.15, 0
    q1, q2, p1, p2 = con_iniciais(q1r, q2r, p2r, E)
    if type(p2) is not complex:
        checa = True

# Parâmetros
h = 0.1  # passo de tempo
t_max = 200  # tempo máximo de simulação


q1_a, q2_a, p1_a, p2_a = None, None, None, None #valores a interação atual

#lista para armazenar os parâmetros para construir o espaço de fase
lista_henon = []
t_henon = []
q2_henon = []
p2_henon = []
q1_henon = []
p1_henon = []

# Loop principal
for t in np.arange(0, t_max, h):
  try:
    q1_a, q2_a, p1_a, p2_a = q1, q2, p1, p2
    q1, q2, p1, p2 = euler_simp(q1, q2, p1, p2, h) #calcula euler simple´tico

    if p1 > 2 or q1 > 2 or p2 > 1 or q2 > 1: #caso o valor exceda esses limites ele não continua a interação (para não divergir)
        continue

    if q1*q1_a < 0 and p1 >= 0:  #Seção de Poincaré no plano p2 x q2
      lista_henon.append(list(henon(q1, q2, p1, p2, 0 - q1))) #determina os componentes da seção de poincaré
      t_henon.append(t) #tempo em que ocorreu a intersecção

  except:
      continue


for element in lista_henon: #retira as componentes de interesse
  q2_henon.append(element[1])
  p2_henon.append(element[3])
  q1_henon.append(element[0])
  p1_henon.append(element[2])

#cria os gráfico
method = 'caótico'
ed_plot(t_henon, q2_henon , 'E = {}'.format(E) ,'r', 1, tx = 't',
        ty = '$q_2(t)$', title = "{0} em função de t em regime {1}".format('$q_2(t)$', method))
ed_plot(t_henon, q1_henon , 'E = {}'.format(E) , 'r', 2,  tx = 't',
        ty = '$q_1(t)$', title = "{0} em função de t em regime {1}".format('$q_1(t)$', method))
ed_plot(t_henon, p2_henon , 'E = {}'.format(E) , 'r', 3,  tx = 't',
        ty = '$p_2(t)$', title = "{0} em função de t em regime {1}".format('$p_2(t)$', method))
ed_plot(t_henon, p1_henon , 'E = {}'.format(E) , 'r', 4,  tx = 't',
        ty = '$p_1(t)$', title = "{0} em função de t em regime {1}" .format('$p_1(t)$', method))

"""Ignorar esta e a próxima célula"""

import numpy as np
import matplotlib.pyplot as plt

# Definindo a Hamiltoniana de Hénon-Heiles
def Henon_Heiles(q, p):
    return 0.5*(p[0]**2 + p[1]**2) + 0.5*(q[0]**2 + q[1]**2) + q[0]**2*q[1] - (1/3)*q[1]**3

# Definindo as equações de movimento
def equations_of_motion(t, y):
    q = y[0:2]
    p = y[2:4]
    dqdt = [p[0], p[1]]
    dpdt = [-q[0] - 2*q[0]*q[1], -q[1] - (q[0]**2 - q[1]**2)]
    return np.array(dqdt + dpdt)

# Implementando o método de Euler simplético
def symplectic_euler(t, y, h, equations_of_motion):
    q_old = y[0:2]
    p_old = y[2:4]
    p_new = p_old + h * np.array(equations_of_motion(t, y)[2:4])
    q_new = q_old + h * p_new
    return np.array([q_new[0], q_new[1], p_new[0], p_new[1]])

# Parâmetros iniciais
y0 = [0.499, 0, 0, 0.137]
t = 0
h = 0.01
num_steps = 100  # Número de passos de tempo

# Inicialização de arrays para armazenar a trajetória
trajectory = np.zeros((num_steps, 4))

# Loop para calcular a trajetória
for i in range(num_steps):
    trajectory[i] = y0
    y0 = symplectic_euler(t, y0, h, equations_of_motion)
    t += h

# Extrair as coordenadas de posição q da matriz trajectory
q1 = trajectory[:, 0]
q2 = trajectory[:, 1]

plt.figure(figsize=(8, 6))
plt.plot(q1, q2, label='Trajetória', color='b')
plt.title('Trajetória do Sistema Hénon-Heiles')
plt.xlabel('q1')
plt.ylabel('q2')
plt.legend()
plt.grid()
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Definindo a Hamiltoniana de Hénon-Heiles e calculando a energia total
def Henon_Heiles(q, p):
    return 0.5 * (p[0]**2 + p[1]**2) + 0.5 * (q[0]**2 + q[1]**2) + q[0]**2 * q[1] - (1/3) * q[1]**3

# Definindo as equações de movimento
def equations_of_motion(t, y):
    q = y[0:2]
    p = y[2:4]
    dqdt = [p[0], p[1]]
    dpdt = [-q[0] - 2 * q[0] * q[1], -q[1] - (q[0]**2 - q[1]**2)]
    return np.array(dqdt + dpdt)

# Implementando o método de Euler simplético
def symplectic_euler(t, y, h, equations_of_motion):
    q_old = y[0:2]
    p_old = y[2:4]
    p_new = p_old + h * np.array(equations_of_motion(t, y)[2:4])
    q_new = q_old + h * p_new
    return np.array([q_new[0], q_new[1], p_new[0], p_new[1]])

# Parâmetros iniciais
E_desired = 0.08333  # Energia desejada
y0 = [0.499, 0, 0, 0.137]
t = 0
h = 0.01

# Inicialização de arrays para armazenar a trajetória
max_steps = 100000  # Número máximo de passos de tempo
trajectory = np.zeros((max_steps, 4))
trajectory[0] = y0
step_count = 0

# Loop para calcular a trajetória com a energia desejada
while step_count < max_steps - 1:
    y0 = symplectic_euler(t, y0, h, equations_of_motion)
    step_count += 1
    trajectory[step_count] = y0
    t += h

print("A trajetória é: {}".format(trajectory[0][0]))
# Construir a seção de Poincaré
poincare_points = []
for i in range(1, step_count - 1):
    if trajectory[i][2]**2 + trajectory[i][3]**2 < 0.0001 and trajectory[i - 1][2] > 0 and trajectory[i][2] < 0:

      poincare_points.append(trajectory[i])



poincare_points = np.array(poincare_points)
q1_poincare = poincare_points[1]
q2_poincare = poincare_points[0]

# Plotar a seção de Poincaré
plt.figure(figsize=(8, 6))
plt.scatter(q1_poincare, q2_poincare, s=2, label='Seção de Poincaré', color='r')
plt.title('Seção de Poincaré para E = 0.08333')
plt.xlabel('q1')
plt.ylabel('q2')
plt.legend()
plt.grid()
plt.show()